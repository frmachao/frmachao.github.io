<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>阅读笔记《区块链技术与应用》</title>
    <link href="/posts/b1a85f07/"/>
    <url>/posts/b1a85f07/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="密码学原理"><a href="#密码学原理" class="headerlink" title="密码学原理"></a>密码学原理</h2><h3 id="比特币中-Hash-算法的特性"><a href="#比特币中-Hash-算法的特性" class="headerlink" title="比特币中 Hash 算法的特性"></a>比特币中 Hash 算法的特性</h3><ul><li>hash collision resistance 哈希碰撞💥  x≠y ,H(x)=H(y) 像这样 两个不同的输入算出的hash 值是相等的，这就是hash 碰撞</li><li>hiding  x—&gt;H(x) 输入到输出是不可逆的</li></ul><p>digital commitment  sealed envelope</p><p>现实中的例子：预测结果提前公布了，会影响结果，sealed envelope 就是找一个可信的地方存起来预测结果，等次日结果出来后，对比是不是预测对了。</p><p>数字中的例子就是 hash 函数加密，因为不可逆性 和 不可人为哈希碰撞性。   </p><ul><li>puzzle friendly  hash 值的计算是不可预测的，比如产生 000…xx..x 这样的hash 值，实现并不知道什么样的输入更有可能算出这样的hash 值</li></ul><p>H(block header) ≤ target (符合要求的hash) 挖矿就是算出这个 nonce，挖矿很难其他人验证这个 nonce 是不是符合要求却很容易。</p><p>SHA-256 比特币中用的 Hash 算法</p><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><ul><li>非对称加密  对称加密 通过 一个encyption 来验证，但是需要安全的环境，不然 密钥泄露就能解析出信息。  于是 就有了 public key, private key  公钥和私钥 这种<code>非对称加密设计</code>出现。  非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。  因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。  电子钱包里就是本地产生一个私钥</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="哈希指针-has-pointers"><a href="#哈希指针-has-pointers" class="headerlink" title="哈希指针 has pointers"></a>哈希指针 has pointers</h3><p>代替了普通的指针，区块链就是使用了哈希指针的链表</p><p>tamper-evident log 记录</p><h3 id="merkle-tree"><a href="#merkle-tree" class="headerlink" title="merkle tree"></a>merkle tree</h3><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2023-04-09-kXSIKX.jpg" alt="merkle tree"><br>merkle proof 流程：<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2023-04-09-zvOg2X.jpg" alt="zvOg2X"></p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记《javaScript DOM 编程艺术》</title>
    <link href="/posts/210b5058/"/>
    <url>/posts/210b5058/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2021-11-09-WmerG5.jpg" alt="2021-11-09-WmerG5"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一本出版于<code>2011</code>年的技术书籍，书中的很多<code>API</code> 可能已经过时，现在有更好更便捷的 API。<code>W3C</code>的<code>DOM标准</code>是开发<code>Web</code>应用的基石，虽然我入行以来一直在用<code>react/vue/angular</code> 之类的前端框架编写<code>web</code>应用，已经不用直接操作 DOM，但浏览器页面还是 DOM 那套东西，加上书中编程艺术的思想，这些都是值得一读的。</p><blockquote><p>写于 2021/10/21</p></blockquote><h2 id="什么是-DOM-Document-Object-Model"><a href="#什么是-DOM-Document-Object-Model" class="headerlink" title="什么是 DOM (Document Object Model)"></a>什么是 DOM (Document Object Model)</h2><p>DOM 本质时一种 API(应用编程接口)。简单地来说，API 就是一组已经得到有关各方共同认可的基本约定。现实世界中，相当于 API 的例子包括摩尔斯码、国际时区；</p><p>在软件编程领域，虽然存在着多种不同的语言，但很多任务却是相同或相似的。这也正是人们需要 API 的原因。一旦掌握了某个标准，就可以把它应用在许多不同的环境中。虽然语法会因为使用的程序设计语言而有所变化，但这些约定却总是保持不变的。</p><p>DOM 是一种适用于多种环境和多种，程序设计语言的通用型 API</p><blockquote><p>tips: 在标准化 DOM 出现前给 20 世纪 90 年代后期的程序员们造成痛苦回忆的 “DHTML”.<br>“DHTML 是“Dynamic HTML”（动态 HTML）的简称。DHTML 并不是一项新技术，而是描述 HTML、CSS 和 JavaScript 技术组合的术语。”</p></blockquote><p>DOM 把文档表示为一棵树</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/wejP2v.png" alt="wejP2v"></p><p>根元素就是<code>html</code>。</p><p>第二层是 <code>head</code> 和 <code>body</code> ，他们是平级元素。<code>head</code>有两个子元素 ：<code>meta</code> 和 <code>title</code>。<code>body</code>下面就是我们日常编写的 html 元素了</p><p>DOM 是由节点构成的集合，元素节点、文本节点、属性节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;balbal..&quot;</span>&gt;</span>文本内容...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>p 标签就是元素节点，<code>&lt;p&gt;xxxx&lt;/p&gt;</code> 元素中的文本就是文本节点，<code>title</code>就是属性节点</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><blockquote><p>css（层叠样式表）,告诉浏览器如何显示一份文档的内容。</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承 （inheritance）是 CSS 技术中的一项强大功能。类似于 DOM，CSS 也把文档的内容视为一棵节点树。节点树上的各个元素将继承其父元素的样式属性。</p><p>例如，如果我们为 body 元素定义了一些颜色或字体，包含在 body 元素里的所有元素都将自动获得那些样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background-color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些颜色将不仅作用于那些直接包含在<body>标签里的内容，还将作用于嵌套在 body 元素内部的所有元素</p><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>这本书出版于 2011 年，那时的 dom 操作 获取元素的方式只有三种</p><ul><li>document.getElementById 通过元素 ID 获取，返回一个对象</li><li>document.getElementsByTagName 通过标签名获取，返回一个对象数组</li><li>document.getElementsByClassName 通过类名获取，返回一个对象数组</li></ul><h2 id="获取和设置属性"><a href="#获取和设置属性" class="headerlink" title="获取和设置属性"></a>获取和设置属性</h2><ul><li>getAttribute 获取文档属性</li><li>setAttribute 设置文档属性 element.setAttribute(attributename,attributevalue)</li></ul><p>这俩方法不属于 document 对象，只能通过元素节点对象调用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> paras = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;p&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt; paras.length; i++) &#123;<br>  <span class="hljs-keyword">var</span> title_text = paras[i].getAttribute(<span class="hljs-string">&quot;title&quot;</span>);<br>  <span class="hljs-keyword">if</span> (title_text) &#123;<br>    paras[i].setAttribute(<span class="hljs-string">&quot;title&quot;</span>,<span class="hljs-string">&quot;brand new title text&quot;</span>);<br>    alert(paras[i].getAttribute(<span class="hljs-string">&quot;title&quot;</span>));<br>  &#125;<br>&#125;<br>摘录来自: Jeremy Keith. “JavaScript DOM编程艺术(第<span class="hljs-number">2</span>版)（图灵图书)<br></code></pre></td></tr></table></figure><h2 id="一个案例：web-图片库"><a href="#一个案例：web-图片库" class="headerlink" title="一个案例：web 图片库"></a>一个案例：web 图片库</h2><ol><li>学习如何利用<code>DOM</code>提供的方法去编写脚本</li><li>学习如何利用事件处理函数把<code>JavaScript</code>代码与网页集成在一起</li></ol><p>介绍了 <code>DOM</code> 提供的几个新属性:</p><ul><li>childNodes</li><li>nodeType 获取或设置元素文本值</li><li>nodeValue 获取节点类型</li><li>firstChild childNodes 中的第一个元素</li><li>lastChild childNodes 中最后一个元素</li></ul><p>其中 nodeType 属性可以获取节点类型。nodetype 属性总共有 12 种可取值，但其中仅有 3 种具有实用价值。</p><ul><li>元素节点的 nodeType 属性值是 1</li><li>属性节点的 nodeType 属性值是 2</li><li>文本节点的 nodeType 属性值是 3</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showPic</span>(<span class="hljs-params">whichpic</span>) </span>&#123;<br>  <span class="hljs-comment">// 获取传入元素的属性</span><br>  <span class="hljs-keyword">var</span> source = whichpic.getAttribute(<span class="hljs-string">&quot;href&quot;</span>);<br>  <span class="hljs-comment">// 获取占位图</span><br>  <span class="hljs-keyword">var</span> placeholder = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;placeholder&quot;</span>);<br>  <span class="hljs-comment">// 更改img元素的src属性 来到达切换图片显示</span><br>  placeholder.setAttribute(<span class="hljs-string">&quot;src&quot;</span>, source);<br>  <span class="hljs-keyword">var</span> text = whichpic.getAttribute(<span class="hljs-string">&quot;title&quot;</span>);<br>  <span class="hljs-keyword">var</span> description = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;description&quot;</span>);<br>  <span class="hljs-comment">// 更改文本节点的值</span><br>  description.firstChild.nodeValue = text;<br>&#125;<br></code></pre></td></tr></table></figure><p>事件处理函数的工作机制。在给某个元素添加了事件处理函数后，一旦事件发生，相应的 JavaScript 代码就会得到执行。</p><p>被调用的 JavaScript 代码可以返回一个值，这个值将被传递给那个事件处理函数。<br>例如，我们可以给某个链接添加一个 onclick 事件处理函数，并让这个处理函数所触发的 JavaScript 代码返回布尔值 true 或 false 。</p><p>这样一来，当这个链接被点击时，如果那段 JavaScript 代码返回的值是 true ，onclick 事件处理函数就认为“这个链接被点击了”；</p><p>反之，如果返回的值是 false ，onclick 事件处理函数就认为“这个链接没有被点击”。</p><p>给<code>a</code>标签的 onclick 事件添加<code>return false</code> 就可以阻止<code>a</code>标签点击跳转链接的默认行为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- “使用this 关键字。这个关键字在这儿的含义是“这个对象”。具体到当前的例子，this 表示“这个&lt;a&gt; 元素节点”” --&gt;</span><br>  &lt;a<br>    onclick=&quot;showPic(this);return false;&quot;<br>    href=&quot;https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/4nnHSd.jpg&quot;<br>    title=&quot;A fireworks display&quot;<br>  &gt;<br>    Fireworks<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>平稳退化，禁用 javascript? 2021 年现在谁还关心这个，禁用 js 是吧网站直接不让使用</li></ul><h3 id="“javascript-”伪协议"><a href="#“javascript-”伪协议" class="headerlink" title="“javascript:”伪协议"></a>“javascript:”伪协议</h3><blockquote><p>“真”协议用来在因特网上的计算机之间传输数据包，如 HTTP 协议（http://）、FTP 协议（ftp://）等，伪协议则是一种非标准化的协议。“javascript:”伪协议让我们通过一个链接来调用 JavaScript 函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popUp</span>(<span class="hljs-params">winURL</span>) </span>&#123;<br>  <span class="hljs-built_in">window</span>.open(winURL,<span class="hljs-string">&quot;popup&quot;</span>,<span class="hljs-string">&quot;width=320,height=480&quot;</span>);<br>&#125;<br>&lt;a href=<span class="hljs-string">&quot;javascript:popUp(&#x27;http://www.example.com/&#x27;);&quot;</span>&gt;Example&lt;/a&gt;<br><span class="hljs-comment">// 内嵌处理函数的方式调用</span><br>&lt;a href=<span class="hljs-string">&quot;#&quot;</span> onclick=<span class="hljs-string">&quot;popUp(&#x27;http://www.example.com/&#x27;); return false;&quot;</span>&gt;Example&lt;/a&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观后感 纪录片《人格的真相》</title>
    <link href="/posts/1f723736/"/>
    <url>/posts/1f723736/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2021-11-07-6xFP3P.jpg" alt="2021-11-07-6xFP3P"></p><h2 id="一项-1975-年的调查问卷内容："><a href="#一项-1975-年的调查问卷内容：" class="headerlink" title="一项 1975 年的调查问卷内容："></a>一项 1975 年的调查问卷内容：</h2><ol><li> 随着年龄的增长 你会变得越来越没用？</li><li> 随着你变老，情况是变好了还是和之前一样？</li></ol><p>上面问题的结果可能会影响你的寿命，通过对比参与实验的人群的死亡数据得出乐观的人要比悲观的人寿命长 7 年多</p><h2 id="心理学是门科学，不是玄学"><a href="#心理学是门科学，不是玄学" class="headerlink" title="心理学是门科学，不是玄学"></a>心理学是门科学，不是玄学</h2><p>实验中用到了很多科学仪器：检测脑电活动</p><p>科学证实左右脑功能是不同的：在不同的活动下，左右脑检测到的脑电活动不同</p><p>意识会以物质的形式存在吗？我们常说刻在 DNA 里的记忆 是怎样保留下来的呢？</p><h2 id="part2-调查问卷的问题："><a href="#part2-调查问卷的问题：" class="headerlink" title="part2 调查问卷的问题："></a>part2 调查问卷的问题：</h2><ol><li>人们认为自己快乐，但是当填写了长长的问卷后人们会觉得自己不快乐<br> 讲诉者佩戴了一种手环大致是能坚持人的压力状态，测试结果跟实际情况类似，讲述者有轻微的社交恐惧，而且长期心理紧张，睡眠质量不好。</li></ol><blockquote><p>讲诉者自己焦虑的原因：</p></blockquote><p>太容易被自己的思想左右，不懂得享受当下</p><h2 id="part3-认知偏见修正"><a href="#part3-认知偏见修正" class="headerlink" title="part3 认知偏见修正"></a>part3 认知偏见修正</h2><ul><li>对着不同情绪表情的图片 进行训练，感觉不靠谱，还不如每天看新闻联播；</li><li>冥想</li><li>每天拿出 10 分钟进行冥想</li><li>科学仪器研究表明，长期冥想的人（8 周以上）他们的大脑左前额叶皮质活跃度增加了、大脑灰质也增加了</li><li>冥想并不会很简单，只是方式很简单，需要天天坚持才能看到结果</li><li>如何冥想？</li><li>从上到下感受自己的身体，感觉一下身体的哪个部分感到放松，哪个部分感到紧张，如果有杂念很正常，让这些想法自由的的来去</li><li>目的是为了训练大脑，让他思想更集中，压力也会减少</li></ul><h2 id="part4-追溯根源"><a href="#part4-追溯根源" class="headerlink" title="part4 追溯根源"></a>part4 追溯根源</h2><ul><li>讲诉者开始回忆小时候，自己单纯 快乐的童年，无忧无虑，父亲很少陪伴自己</li><li>先天基因与后天经历共同作用的结果</li><li>通过对双胞胎的研究来研究基因和后天经历对性格的影响</li><li>遗传因素占 40%—50%</li><li>基因不是一层不变的，基因片段中的东西会随着后天经历改变</li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><blockquote><p>讲诉者经过 7 周的冥想后：</p></blockquote><ul><li>他的妻子感觉他有改变，压力变小了，睡眠也有改善。</li><li>仪器检测后发现 大脑右前额叶皮质活跃度降低了很多。</li><li>样本量很小 无法代表所有人，但是每天 10 分钟为什么不试试呢？</li><li>想改变性格，永远都不晚，乐观一些吧。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>纪录片</tag>
      
      <tag>观点感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记《最好的告别》</title>
    <link href="/posts/f2c957b0/"/>
    <url>/posts/f2c957b0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2021-11-07-dez79U.jpg" alt="2021-11-07-dez79U"></p><h2 id="什么时候应该放弃治疗"><a href="#什么时候应该放弃治疗" class="headerlink" title="什么时候应该放弃治疗"></a>什么时候应该放弃治疗</h2><p>姑息治疗，应该减少医学治疗 ，增加医学护理，尝试新的安宁缓和医疗模式（通过关怀与抚慰的手段），善终服务就是姑息治疗，就是通过给予相应的照料帮助病人处理这些困难。</p><p>一个国家医疗发展的阶段：</p><ol><li>国家极度贫困，没有医疗条件，只能在家等死</li><li>经济发展 公共卫生医疗条件提升，在医院去世</li><li>经济物质高度发达，开始注重生命的质量，居家离世变多。参考美国</li></ol><h2 id="三种医患关系："><a href="#三种医患关系：" class="headerlink" title="三种医患关系："></a>三种医患关系：</h2><ul><li>家长型：<br>我们是医学权威，目的是确保病人接受我们认为对他最好的治疗。我们有知识和经验，负责作出关键的抉择。如果有一粒红色药片和一粒蓝色药片，我们会告诉你：“吃红色药片，这对你好。”我们可能会给你讲讲蓝色药片，但是，我们也可能不讲。我们告诉你我们认为你需要知道的东西。这是一种祭司型的、“医生最明白”的模式，虽然经常遭到谴责，但目前仍然是普遍的医患交往模式，尤其对于易受伤害的病人——虚弱的、贫穷的、老年的，以及所有容易听从指令的人。</li><li>资讯型：<br>同家长型关系正好相反。我们告诉患者事实和数据，其他一切随患者来裁决。</li><li>解释型：<br>上面两种类型的关系都不是人们想要的。我们既想了解信息，又需要掌控和裁决权，同时我们也需要指导。伊曼纽尔夫妇把第三种医患关系称为“解释型”关系。在这种关系中，医生的角色是帮助病人确定他们想要什么。<br>专家把这种方式称为共同决策模式</li></ul><h2 id="ODTAA-综合征（One-Damn-Thing-After-AnotherSyndrome，直译为“该死的事一件接着一件综合征”）"><a href="#ODTAA-综合征（One-Damn-Thing-After-AnotherSyndrome，直译为“该死的事一件接着一件综合征”）" class="headerlink" title="ODTAA 综合征（One Damn Thing After AnotherSyndrome，直译为“该死的事一件接着一件综合征”）"></a>ODTAA 综合征（One Damn Thing After AnotherSyndrome，直译为“该死的事一件接着一件综合征”）</h2><h2 id="理解个人生命的有限性"><a href="#理解个人生命的有限性" class="headerlink" title="理解个人生命的有限性"></a>理解个人生命的有限性</h2><h3 id="勇气"><a href="#勇气" class="headerlink" title="勇气"></a>勇气</h3><p>她的困难不是面对风险缺少采取行动的勇气，而是希望能搞清楚如何看待这些风险。她说自己最大的恐惧是受苦。虽然做手术是为了减少她的痛苦，但是，手术会不会使情况更糟而不是更好呢</p><h2 id="峰值定律："><a href="#峰值定律：" class="headerlink" title="峰值定律："></a>峰值定律：</h2><p>“峰终定律”（Peak-End rule）可以得到最好的预测：只计算在两个时刻体验到的平均疼痛，即过程中最糟糕的一个时刻和最后时刻。根据强度最大的疼痛水平和检查结束时的水平，而不是根据疼痛总量，胃肠病医生对于他们给病人造成的疼痛的估计与病人自己的估计非常相似。<br>人好像有两个不同的自我：体验的自我平等地忍受每时每刻的体验，而记忆的自我事后几乎把全部的判断权重放在两个时刻上，即最糟糕的时刻和最后的时刻。即便在结果异常的情况下，记忆的自我也似乎坚持峰终定律。即便刚刚经受了半个多小时的高水平疼痛，只要在医疗过程结束时有那么几分钟不痛，病人对总体疼痛的评价就会戏剧性地降低。事后他们报告说：“没有那么可怕。”而糟糕结尾则同样戏剧性地推升疼痛评分。<br>多个背景下的研究都证实了峰终定律以及我们对疼痛长度的忽视。研究还说明，这个现象也同样适用于人们对愉快经验的评价。<br>然而，我们也认识到，不应该忽视体验的自我——高峰和结尾并不是唯一重要的部分。青睐极度快乐的时刻而忽视稳定的幸福，从这一点来说，记忆的自我并非总是明智的。</p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>观点感想</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一次全栈开发总结</title>
    <link href="/posts/1de4d68a/"/>
    <url>/posts/1de4d68a/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 2020 年 5 月，也就是我参加 web 前端工作的第三个年头。当时我刚离职不久，手头上存了一些钱想着做点自己想做的事，去他妈的工作。当时恰逢疫情，远方肯定是去不了，于是就开始学着拍些视频，跟着 <a href="https://chinese.freecodecamp.org/learn">FreeCodeCamp</a> 学些服务端开发的课程。虽然做开发工作三年了，但一直做 web 前端,对服务端开发不了解，在公司里就像是被用调用的资源，给需求吐页面，像下蛋母鸡一般(<a href="http://www.ruanyifeng.com/blog/2016/07/hen-and-front-end-engineer.html">母鸡与前端工程师</a>)</p><p>趁着自由身，开始从零开始构建一个 web 项目，前端开发环境、服务端开发环境、数据库操作、接口开发、项目部署，全部自己做。首先写东西需要原型和功能，我把目光投到了 2018 年在公司参与的一个内测项目<code>知拾</code>。当时的我只负责了前端中某个功能点的开发，好在这个内测地址还能访问，那我便根据它照猫画虎出来一个自己的 <a href="https://www.frmachao.top/datum">知拾</a></p><h2 id="知拾"><a href="#知拾" class="headerlink" title="知拾"></a>知拾</h2><blockquote><p>知拾是一个个人知识库，提供一套方便快捷的记录和管理知识的工具，让每个人记录自己认为有用的知识。</p></blockquote><ul><li>知识库里面记录的大部分知识都是公开共享的。</li><li>大家可以通过知识库获得其他人认为有用的知识。</li><li>通过搜索功能，知识库希望可以提供一个纯净的知识资源的快速导航。</li><li>知识库将会提供群组功能，让你和你的小伙伴分享和管理互相感兴趣的知识。</li><li>权限控制<ul><li>用户发布的文章有两种：非公开文章 与公开文章 非公开文章 只有你和所属小组能看到该文章。你如果把该文章网址发给其他人，有网址的人也能看到</li><li>小组有两种: 公开小组 、私密小组、 私密小组的名字、简介、成员列表和其他都是私密信息，私密小组发布的文章只能由当前小组成员看到，私密小组无法发布公开文章。 小组创建以后，其公开私密状态将固定无法修改</li></ul></li><li>知拾评论功能<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2021-11-03-ehmddn.png" alt="2021-11-03-ehmddn"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2021-11-03-LqMt5M.png" alt="2021-11-03-LqMt5M"></p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2021-11-03-fHCW8f.png" alt="2021-11-03-fHCW8f"></p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2021-11-03-qOMSzN.png" alt="2021-11-03-qOMSzN"></p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/zpqm2H.png" alt="zpqm2H"></p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><blockquote><p>React 技术栈</p></blockquote><p><code>Typescript + React hooks + Mobx</code> 编写前端应用</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><blockquote><p>Node.js、Express、GraphQL、MongoDB</p></blockquote><p>因为是前端出身对<code>javascript</code>语言比较熟悉，服务端开发就选择了<code>node.js</code> 相关的技术。选择<code>GraphQL</code>接口风格，也是出于对前端调用友好。MongoDB，额这个是因为 跟着<a href="https://chinese.freecodecamp.org/learn/back-end-development-and-apis/">FCC 的 node.js 课程学习</a>时，里面教的数据库就是它。</p><p>好吧，我好懒，不肯多花时间学一门正经的服务端编程语言….</p><ul><li><a href="https://blog.frmachao.top/posts/62bfed46/">网站评论模块 mongodb 字段设计及实现 </a></li></ul><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><ul><li>前端支持<code>React</code>多页面构建以及单页面构建，支持命令行参数</li><li>服务端集成<code>express mongodb graphql</code> 快速开始开发 支持 <code>TypeScript</code> 编写</li><li>批量构建</li><li>多页面网站 集合服务端模板</li><li>添加 eslint、prettier 代码风格约束</li></ul><h3 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录:"></a>工程目录:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">|--<br>    |--build<br>    |--dist 前端打包后的资源没有`html`文件，`html`交给服务端处理<br>        |--mpa<br>            |--page1<br>            |--page2<br>        |--spa1<br>        |--xxx<br>    |--server 网站后端<br>        |--src<br>            |--middlewares<br>            |--controllers<br>            |--models<br>            |--app.ts<br>        |--public<br>        |--view<br>    |--site 网站前端<br>        |--mpa 多页面应用资源目录<br>            |--page1<br>            |--page2<br>        |--spa1<br>        |--spa2<br>        |--xxxx<br></code></pre></td></tr></table></figure><h3 id="具体代码："><a href="#具体代码：" class="headerlink" title="具体代码："></a>具体代码：</h3><p><a href="https://github.com/frmachao/webpack-examples">https://github.com/frmachao/webpack-examples</a></p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h3><p><code>知拾</code>是<a href="https://www.frmachao.top/">frmachao.top</a> 网站里的一个应用，当时我的想法是做一个综合站点，把 web 开发中常用的东西都用上。<br>网站的大体结构：</p><ul><li>头部<ul><li>由服务器静态模板编写：头部、导航栏、登录、注册</li></ul></li><li>内容区域<ul><li>由单页面应用来填充 服务端根据路由动态拼接好单页面应用需要的资源</li></ul></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><blockquote><p>pm2 + shell</p></blockquote><p>我在项目中的使用: 在项目根目录下新建一个 <code>pm2_start.sh</code> 文件，每次提交后项目后，在服务器环境中执行 <code>sh pm2_start.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;拉取git仓库&quot;</span><br>git pull<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;安装前端项目依赖&quot;</span><br>npm i --unsafe-perm<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;安装后端项目依赖&quot;</span><br><span class="hljs-built_in">cd</span> server/ &amp;&amp; npm i --unsafe-perm<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;构建前端&quot;</span><br><span class="hljs-built_in">cd</span> ../ &amp;&amp; npm run build --unsafe-perm<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;构建后端&quot;</span><br><span class="hljs-built_in">cd</span> server &amp;&amp; npm run build --unsafe-perm<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;杀掉所有pm2&quot;</span><br>pm2 <span class="hljs-built_in">kill</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;pm2 启动 node 程序&quot;</span><br>NODE_ENV=production pm2 start dist/app.js<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;设置 centos 开机启动 pm2&quot;</span><br>pm2 startup<br>pm2 save<br></code></pre></td></tr></table></figure><ul><li><a href="https://blog.frmachao.top/posts/7c957dfb/">记录 react+node+mongodb 项目部署到服务器的过程</a></li></ul><h2 id="学到了什么"><a href="#学到了什么" class="headerlink" title="学到了什么"></a>学到了什么</h2><ol><li>熟悉了 <code>Express、MongoDB、GraphQL</code>，针对需求可以做到简单的数据库设计、接口的开发与设计。</li><li>熟练使用 <code>Webpack 、Gulp</code>等工具，对脚手架功能进行定制。</li><li>学习了服务器部署、<code>Nginx</code>服务器的使用、和常用的一些 <code>Linux</code> 命令。</li></ol>]]></content>
    
    
    <categories>
      
      <category>代码人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
      <tag>全栈开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置阿里云轻量应用服务器实现全站HTTPS访问</title>
    <link href="/posts/6d9a362d/"/>
    <url>/posts/6d9a362d/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我写了一个基于<code>React</code>+<code>Express</code>+<code>MongoDB</code>的个人网站 <a href="http://www.frmachao.top/">www.frmachao.top</a>，现在要给它加上 <code>ssl</code> 证书，来实现全站<code>https</code>访问。</p><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><h3 id="购买免费的证书服务"><a href="#购买免费的证书服务" class="headerlink" title="购买免费的证书服务"></a>购买免费的证书服务</h3><p><a href="https://common-buy.aliyun.com/?spm=5176.13785142.commonbuy2container.9.79e8778bjBRbjJ&commodityCode=cas_dv_public_cn&request=%7B%22ord_time%22:%221:Year%22,%22order_num%22:1,%22product%22:%22free_product%22,%22certCount%22:%2220%22%7D">阿里云盾证书服务</a></p><blockquote><p>注意： 单域名表示要申请的证书用于绑定1个具体域名（例如，只绑定<a href="http://www.frmachao.top)/">www.frmachao.top）</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/D0z6dz.png" alt="D0z6dz"></p><h3 id="创建证书并进行证书申请操作"><a href="#创建证书并进行证书申请操作" class="headerlink" title="创建证书并进行证书申请操作"></a>创建证书并进行证书申请操作</h3><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/gj1Mp8.png" alt="gj1Mp8"></p><h3 id="填写申请信息-并验证-DNS-信息"><a href="#填写申请信息-并验证-DNS-信息" class="headerlink" title="填写申请信息 并验证 DNS 信息"></a>填写申请信息 并验证 DNS 信息</h3><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/DdJecL.png" alt="DdJecL"></p><blockquote><p>注意：域名验证记录要在证书签发后再删除，否则因为没有解析记录导致证书签发失败</p></blockquote><p>主机记录值<code>_dnsauth</code> 就是系统自动生成的 域名验证记录 ，因为这里我的域名也是在阿里云解析的，如果你是其他 DNS 服务商解析的，需要自己添加一条这样的域名记录<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/DJ0NyK.png" alt="DJ0NyK"></p><h2 id="搭建FTP服务器"><a href="#搭建FTP服务器" class="headerlink" title="搭建FTP服务器"></a>搭建FTP服务器</h2><blockquote><p>参考：<a href="https://help.aliyun.com/document_detail/60152.html">阿里云文档</a></p></blockquote><p>Q:为什么要搭建FTP服务器<br>A:因为要上传证书到服务器,可能有其他方式上传，但是图形界面更直观些。</p><h3 id="补充常用命令"><a href="#补充常用命令" class="headerlink" title="补充常用命令"></a>补充常用命令</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">启动服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">start</span> <span class="hljs-string">vsftpd</span>.<span class="hljs-string">service</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span>关闭服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">stop</span> <span class="hljs-string">vsftpd</span>.<span class="hljs-string">service</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span>重启服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">restart</span> <span class="hljs-string">vsftpd</span>.<span class="hljs-string">service</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span>显示服务的状态：<span class="hljs-string">systemctl</span> <span class="hljs-string">status</span> <span class="hljs-string">vsftpd</span>.<span class="hljs-string">service</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span>在开机时启用服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">enable</span> <span class="hljs-string">vsftpd</span>.<span class="hljs-string">service</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span>在开机时禁用服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">disable</span> <span class="hljs-string">vsftpd</span>.<span class="hljs-string">service</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span>查看服务是否开机启动：<span class="hljs-string">systemctl</span> <span class="hljs-string">is-enabled</span> <span class="hljs-string">vsftpd</span>.<span class="hljs-string">service</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span>查看已启动的服务列表：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-unit-files|grep</span> <span class="hljs-string">enabled</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span>查看启动失败的服务列表：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">--failed</span><br></code></pre></td></tr></table></figure><h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><ol><li>FileZilla客户端 连接时的加密方式….. 卡了我半天<br>使用文档截图中连接的加密方式时，一直提示连接超时，我以为是配置的FTP服务器有问题，对着文档反复走几遍折腾了 一个小时，最后试了试选择明文连接，结果直接成功了</li></ol><p>😭只要没文化 处处是魔法<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2YSLJ1.jpg" alt="2YSLJ1"></p><h2 id="centos-7-安装-nginx-ssl-模块"><a href="#centos-7-安装-nginx-ssl-模块" class="headerlink" title="centos 7 安装 nginx + ssl 模块"></a>centos 7 安装 nginx + ssl 模块</h2><p>我购买是阿里云轻量应用服务器 CentOS 7 的镜像<br>一开始我直接使用yum方式安装的ngninx，但是这种方式安装的ngninx默认是不支持ssl的，所以需要从代码编译安装Nginx</p><p>参考:</p><ol><li><a href="https://www.cnblogs.com/nickchou/p/12978724.html">centos 7 源码方式安装nginx(1.18.0) + ssl + 阿里证书配置</a></li></ol><h3 id="源码安装-Nginx"><a href="#源码安装-Nginx" class="headerlink" title="源码安装 Nginx"></a>源码安装 Nginx</h3><p>遇到的问题：</p><ol><li>CentOS7中添加环境变量后立即生效，但是重启服务器又失效</li></ol><p>原因：添加环境变量到 /etc/profile文件<br>source /etc/profile 使配置文件生效<br>参考：<a href="https://blog.csdn.net/lxw1844912514/article/details/108547340">CentOS7中添加环境变量后立即生效，但是重启服务器又失效</a></p><h3 id="检查是否已经含有-ssl-模块"><a href="#检查是否已经含有-ssl-模块" class="headerlink" title="检查是否已经含有 ssl 模块"></a>检查是否已经含有 ssl 模块</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -V</span><br></code></pre></td></tr></table></figure><p>看到输出里 含有 <code>--with-http_ssl_module</code> 明就是带ssl参数编译的</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nginx</span> version: nginx/<span class="hljs-number">1</span>.<span class="hljs-number">20</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">built</span> by gcc <span class="hljs-number">4</span>.<span class="hljs-number">8</span>.<span class="hljs-number">5</span> <span class="hljs-number">20150623</span> (Red Hat <span class="hljs-number">4</span>.<span class="hljs-number">8</span>.<span class="hljs-number">5</span>-<span class="hljs-number">44</span>) (GCC) <br><span class="hljs-attribute">built</span> with OpenSSL <span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>k-fips  <span class="hljs-number">26</span> Jan <span class="hljs-number">2017</span><br><span class="hljs-attribute">TLS</span> SNI support enabled<br><span class="hljs-attribute">configure</span> arguments: --prefix=/usr/local/nginx --with-threads --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-http_ssl_module<br></code></pre></td></tr></table></figure><h3 id="在Nginx服务器上安装ssl证书"><a href="#在Nginx服务器上安装ssl证书" class="headerlink" title="在Nginx服务器上安装ssl证书"></a>在Nginx服务器上安装ssl证书</h3><blockquote><p>参考： <a href="https://help.aliyun.com/document_detail/98728.html#title-0np-hxn-v02">在Nginx（或Tengine）服务器上安装证书</a></p></blockquote><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/OAbHnZ.png" alt="OAbHnZ"></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>学习到的linux命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">mv</span>  <span class="hljs-comment"># 移动文件/目录</span><br><span class="hljs-built_in">cp</span>  <span class="hljs-comment"># 复制文件/目录</span><br>touch <span class="hljs-comment"># 用于修改文件或者目录的时间属性，若文件不存在会新建一个</span><br>mkdir <span class="hljs-comment"># 创建目录</span><br>ln   <span class="hljs-comment"># 类似windows 中的快捷方式，这是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</span><br></code></pre></td></tr></table></figure><p>linux 中的几种配置环境变量的文件目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>bashrc <br><span class="hljs-regexp">/etc/</span>profile<br><span class="hljs-regexp">/etc/</span>sudoers<br></code></pre></td></tr></table></figure><h2 id="另一种方案-Let’s-Encrypt"><a href="#另一种方案-Let’s-Encrypt" class="headerlink" title="另一种方案: Let’s Encrypt"></a>另一种方案: <a href="https://letsencrypt.org/zh-cn/about/">Let’s Encrypt</a></h2><blockquote><p>Let’s Encrypt 是一家免费、开放、自动化的证书颁发机构（CA），为公众的利益而运行。它是一项由 Internet Security Research Group（ISRG）提供的服务。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网站评论模块 mongodb 字段设计及实现</title>
    <link href="/posts/62bfed46/"/>
    <url>/posts/62bfed46/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我写了一个基于<code>React+Express+MongoDB</code>的个人网站。<a href="http://101.132.140.62/">http://101.132.140.62/</a>，网站上有个叫做 <a href="http://101.132.140.62/datum">知拾</a> 的单页面应用，它主要是一个知识库类型的应用，人人都可以往里面记录自己认为有用的知识。</p><blockquote><p>现在我想要添加对知识的评论功能</p></blockquote><h2 id="项目开发环境"><a href="#项目开发环境" class="headerlink" title="项目开发环境"></a>项目开发环境</h2><ul><li>MongoDB 4.4.8</li><li>Express 4.17.1</li><li>React 16.13.1</li></ul><h2 id="知拾应用评论区的功能"><a href="#知拾应用评论区的功能" class="headerlink" title="知拾应用评论区的功能"></a>知拾应用评论区的功能</h2><ul><li>支持嵌套评论，最大深度2层</li><li>支持精简版的 markdown 语法<ul><li>那么评论提交的应该是html 而不是 text，(不支持编辑)</li></ul></li><li>评论只能删除不能修改</li><li>评论应该支持分页<ul><li>子评论也要支持分页</li></ul></li><li>增加新评论时邮件通知 <code>知识作者</code> 或者 <code>被回复人</code></li></ul><blockquote><p>参考 B 站评论区</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/FTZrwc.png" alt="FTZrwc"><br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/haVB0N.png" alt="haVB0N"></p><h2 id="数据库字段设计"><a href="#数据库字段设计" class="headerlink" title="数据库字段设计"></a>数据库字段设计</h2><p>如图所示：<code>Article、 Comment 、User</code> 三个集合，通过MongoDB 的 ref 将三个集合关联起来。<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/g2V5mw.png" alt="g2V5mw"></p><h3 id="对应到-Mongoose-中的评论模型"><a href="#对应到-Mongoose-中的评论模型" class="headerlink" title="对应到 Mongoose 中的评论模型"></a>对应到 Mongoose 中的评论模型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> CommentSchema = <span class="hljs-keyword">new</span> mongoose.Schema(&#123;<br>    <span class="hljs-comment">// 评论所在的文章 id 关联 Article 集合</span><br>    datumID: &#123; <span class="hljs-attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>    html: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">validate</span>: <span class="hljs-regexp">/\S+/</span> &#125;,<br>    <span class="hljs-comment">//预留字段 被赞数</span><br>    likes: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>, <span class="hljs-attr">default</span>: <span class="hljs-number">0</span> &#125;,<br>    <span class="hljs-comment">//预留字段 被踩数</span><br>    unlikes: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>, <span class="hljs-attr">default</span>: <span class="hljs-number">0</span> &#125;,<br>    <span class="hljs-comment">// 评论作者信息 关联 User 集合</span><br>    author: &#123;<br>        user: &#123; <span class="hljs-attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="hljs-attr">ref</span>: <span class="hljs-string">&quot;User&quot;</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>        role: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;normal&quot;</span> &#125;, <span class="hljs-comment">// author|normal</span><br>    &#125;,<br>    <span class="hljs-comment">// 创建日期</span><br>    create_time: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">Date</span>, <span class="hljs-attr">default</span>: <span class="hljs-built_in">Date</span>.now &#125;,<br>    <span class="hljs-comment">// 最后修改日期</span><br>    update_time: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">Date</span>, <span class="hljs-attr">default</span>: <span class="hljs-built_in">Date</span>.now &#125;,<br>    child_comments: [<br>        &#123;<br>            <span class="hljs-comment">// 谁在评论  关联 User 集合</span><br>            author: &#123;<br>                user: &#123; <span class="hljs-attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="hljs-attr">ref</span>: <span class="hljs-string">&quot;User&quot;</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>                role: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;normal&quot;</span> &#125;, <span class="hljs-comment">// author|normal</span><br>            &#125;,<br>            <span class="hljs-comment">// 对谁评论  关联 User 集合</span><br>            reply_to_author: &#123;<br>                user: &#123; <span class="hljs-attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="hljs-attr">ref</span>: <span class="hljs-string">&quot;User&quot;</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>                role: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;normal&quot;</span> &#125;, <span class="hljs-comment">// author|normal &#125;,</span><br>            &#125;,<br>            html: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">validate</span>: <span class="hljs-regexp">/\S+/</span> &#125;,<br>            <span class="hljs-comment">// 被赞数</span><br>            likes: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>, <span class="hljs-attr">default</span>: <span class="hljs-number">0</span> &#125;,<br>            <span class="hljs-comment">// 被踩数</span><br>            unlikes: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>, <span class="hljs-attr">default</span>: <span class="hljs-number">0</span> &#125;,<br>            <span class="hljs-comment">// 创建日期</span><br>            create_time: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">Date</span>, <span class="hljs-attr">default</span>: <span class="hljs-built_in">Date</span>.now &#125;,<br>        &#125;,<br>    ],<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="评论功能实现"><a href="#评论功能实现" class="headerlink" title="评论功能实现"></a>评论功能实现</h2><p>因为没有编辑评论内容的需求，所以只要实现增加(Create)、读取(Retrieve)、和删除(Delete)</p><ol><li>添加<ul><li>添加父评论</li><li>添加子评论</li></ul></li><li>查询<ul><li>获取父评论列表接口</li><li>获取子评论列表接口</li></ul></li><li>删除<ul><li>删除父评论</li><li>删除子评论</li></ul></li></ol><h3 id="实际项目中对应的代码"><a href="#实际项目中对应的代码" class="headerlink" title="实际项目中对应的代码"></a>实际项目中对应的代码</h3><blockquote><p>Tips 项目中我使用了 GraphQL 接口风格 <a href="https://graphql.cn/">什么是Graphql</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理 async 函数中的异常</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">promise</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">awaitWrap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span> = <span class="hljs-title">Error</span>&gt;(<span class="hljs-params">promise: <span class="hljs-built_in">Promise</span>&lt;T&gt;</span>): <span class="hljs-title">Promise</span>&lt;[<span class="hljs-title">U</span> | <span class="hljs-title">null</span>, <span class="hljs-title">T</span> | <span class="hljs-title">null</span>]&gt; </span>&#123;<br>    <span class="hljs-keyword">return</span> promise<br>        .then&lt;[<span class="hljs-literal">null</span>, T]&gt;(<span class="hljs-function">(<span class="hljs-params">data: T</span>) =&gt;</span> [<span class="hljs-literal">null</span>, data])<br>        .catch&lt;[U, <span class="hljs-literal">null</span>]&gt;(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> [err, <span class="hljs-literal">null</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>创建父评论：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js">add: <span class="hljs-keyword">async</span> (args: Iadd, <span class="hljs-attr">context</span>: any) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; datumID, html, author &#125; = args;<br>    <span class="hljs-keyword">if</span> (!context.req.user) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;未登陆用户无权限&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查询文章获取文章相关信息</span><br>    <span class="hljs-keyword">const</span> [errArticle, result] = <span class="hljs-keyword">await</span> awaitWrap&lt;ArticleDocument&gt;(<br>        Article.findOne(&#123; <span class="hljs-attr">_id</span>: datumID &#125;, &#123; <span class="hljs-attr">author</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-number">1</span> &#125;)<br>            .populate(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;author&quot;</span> &#125;)<br>            .exec()<br>    );<br>    <span class="hljs-keyword">if</span> (errArticle) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;添加评论失败1&quot;</span>;<br>    <span class="hljs-keyword">const</span> [err, newComment] = <span class="hljs-keyword">await</span> awaitWrap(<br>        Comment.create(&#123;<br>            datumID,<br>            html,<br>            author: &#123;<br>                user: author,<br>                role: getRole(author, result.author._id.toString()),<br>            &#125;,<br>            child_comments: [],<br>        &#125;)<br>    );<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;添加评论失败2&quot;</span>;<br>    <span class="hljs-keyword">const</span> &#123; req &#125; = context;<br>    <span class="hljs-comment">// 邮件通知作者 谁评论</span><br>    <span class="hljs-keyword">const</span> sendApplyJoinEmail = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> transporter = nodemailer.createTransport(&#123;<br>            service: <span class="hljs-string">&quot;126&quot;</span>,<br>            auth: &#123;<br>                user: process.env.SMTP_USER,<br>                pass: process.env.SMTP_PASSWORD,<br>            &#125;,<br>        &#125;);<br>        <span class="hljs-keyword">const</span> mailOptions = &#123;<br>            to: result.author.email,<br>            <span class="hljs-keyword">from</span>: process.env.SMTP_USER,<br>            subject: <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;context.req.user.profile.name&#125;</span>&quot;评论了你的知识《<span class="hljs-subst">$&#123;result.title&#125;</span>》`</span>,<br>            html: <span class="hljs-string">`点击下面链接处理:</span><br><span class="hljs-string">            &lt;p/&gt;</span><br><span class="hljs-string">            &lt;a href=&quot;<span class="hljs-subst">$&#123;req.headers.origin&#125;</span>/datum/view?id=<span class="hljs-subst">$&#123;datumID&#125;</span>&quot;&gt;<span class="hljs-subst">$&#123;req.headers.origin&#125;</span>/datum/view?id=<span class="hljs-subst">$&#123;datumID&#125;</span>&lt;/a&gt;`</span>,<br>        &#125;;<br>        transporter.sendMail(mailOptions);<br>    &#125;;<br>    sendApplyJoinEmail();<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;ok&quot;</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;添加成功&quot;</span>, <span class="hljs-attr">commentID</span>: newComment._id &#125;;<br>&#125;,<br><br></code></pre></td></tr></table></figure><p>现在我们添加一条父评论测试一下接口：<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/tbIzXv.png" alt="tbIzXv"><br>然后去数据库中查看：<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/NO3YVi.png" alt="NO3YVi"></p><p>创建子评论：主要通过 <code>$push</code> 操作符实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs js">addChild: <span class="hljs-keyword">async</span> (args: IaddChild, <span class="hljs-attr">context</span>: any) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; id, datumID, html, author, reply_to_author &#125; = args;<br>    <span class="hljs-keyword">if</span> (!context.req.user) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;未登陆用户无权限&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查询文章获取文章作者</span><br>    <span class="hljs-keyword">const</span> [errArticle, result] = <span class="hljs-keyword">await</span> awaitWrap(<br>        Article.findOne(&#123; <span class="hljs-attr">_id</span>: datumID &#125;, &#123; <span class="hljs-attr">author</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-number">1</span> &#125;)<br>            .populate(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;author&quot;</span> &#125;)<br>            .exec()<br>    );<br>    <span class="hljs-keyword">if</span> (errArticle) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;添加评论失败&quot;</span>;<br><br>    <span class="hljs-keyword">const</span> [err] = <span class="hljs-keyword">await</span> awaitWrap(<br>        Comment.updateOne(<br>            &#123; <span class="hljs-attr">_id</span>: id &#125;,<br>            &#123;<br>                $push: &#123;<br>                    child_comments: &#123;<br>                        author: &#123;<br>                            user: author,<br>                            role: getRole(author, result.author._id.toString()),<br>                        &#125;,<br>                        reply_to_author: &#123;<br>                            user: reply_to_author,<br>                            role: getRole(reply_to_author, result.author._id.toString()),<br>                        &#125;,<br>                        html,<br>                    &#125;,<br>                &#125;,<br>            &#125;<br>        ).exec()<br>    );<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;添加评论失败&quot;</span>;<br>    <span class="hljs-keyword">const</span> &#123; req &#125; = context;<br>    <span class="hljs-comment">// 发邮件给 reply_to_author</span><br>    <span class="hljs-keyword">const</span> [errUser, data] = <span class="hljs-keyword">await</span> awaitWrap&lt;UserDocument&gt;(<br>        User.findOne(&#123; <span class="hljs-attr">_id</span>: reply_to_author &#125;).exec()<br>    );<br>    <span class="hljs-keyword">if</span> (errUser) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;添加评论失败&quot;</span>;<br>    <span class="hljs-keyword">const</span> sendApplyJoinEmail = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> transporter = nodemailer.createTransport(&#123;<br>            service: <span class="hljs-string">&quot;126&quot;</span>,<br>            auth: &#123;<br>                user: process.env.SMTP_USER,<br>                pass: process.env.SMTP_PASSWORD,<br>            &#125;,<br>        &#125;);<br>        <span class="hljs-keyword">const</span> mailOptions = &#123;<br>            to: data.email,<br>            <span class="hljs-keyword">from</span>: process.env.SMTP_USER,<br>            subject: <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;context.req.user.profile.name&#125;</span>&quot;在《<span class="hljs-subst">$&#123;result.title&#125;</span>》回复了你`</span>,<br>            html: <span class="hljs-string">`点击下面链接处理:</span><br><span class="hljs-string">                    &lt;p/&gt;</span><br><span class="hljs-string">                    &lt;a href=&quot;<span class="hljs-subst">$&#123;req.headers.origin&#125;</span>/datum/view?id=<span class="hljs-subst">$&#123;datumID&#125;</span>&quot;&gt;<span class="hljs-subst">$&#123;req.headers.origin&#125;</span>/datum/view?id=<span class="hljs-subst">$&#123;datumID&#125;</span>&lt;/a&gt;`</span>,<br>        &#125;;<br>        transporter.sendMail(mailOptions);<br>    &#125;;<br>    sendApplyJoinEmail();<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;ok&quot;</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;添加成功&quot;</span> &#125;;<br>&#125;,<br></code></pre></td></tr></table></figure><p>现在我们添加一条子评论测试一下接口：<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/1IuESr.png" alt="1IuESr"><br>然后去数据库中查看：<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/x8m6z5.png" alt="x8m6z5"></p><p>读取(Retrieve)、和删除(Delete) 的接口类似，我这里就不贴了..</p><ul><li>子评论分页主要通过 <code>$slice</code> 和 <code>$size</code> 操作符实现</li><li>删除子评论 通过<code>$pull</code>操作法实现</li></ul><h3 id="不要相信前端传来的数据！"><a href="#不要相信前端传来的数据！" class="headerlink" title="不要相信前端传来的数据！"></a>不要相信前端传来的数据！</h3><p>‘author.role’的值应通过查询文章获取作者id 和 当前登陆用户id 在后端比较出来的, 同理 reply_to_author.role 也是一样。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="MongoDB-对嵌套的数组对象使用-lookup操作法"><a href="#MongoDB-对嵌套的数组对象使用-lookup操作法" class="headerlink" title="MongoDB 对嵌套的数组对象使用 $lookup操作法"></a>MongoDB 对嵌套的数组对象使用 $lookup操作法</h3><p>因为 Comment 集合中的 child_comments 字段是一个数组对象</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">child_comments:[<br><span class="hljs-code">    &#123;author:&#123;user,role&#125;,reply_to_author,....&#125;</span><br>]<br><br></code></pre></td></tr></table></figure><p>当我做通过 $lookup 操作符做多表关联查找操作时,child_comments 中的字段会被覆盖</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 执行</span><br>&#123;<br>$lookup: &#123;<br><span class="hljs-symbol">from:</span> <span class="hljs-string">&quot;users&quot;</span>,<br><span class="hljs-symbol">localField:</span> <span class="hljs-string">&quot;child_comments.author.user&quot;</span>,<br><span class="hljs-symbol">foreignField:</span> <span class="hljs-string">&quot;_id&quot;</span>,<br><span class="hljs-symbol">as:</span> <span class="hljs-string">&quot;child_comments.author.user&quot;</span>,<br>&#125;,<br>&#125;<br><span class="hljs-comment">// 实际返回的 child_comments 数组对象中 author.role 字段没有了</span><br>    <span class="hljs-string">&quot;child_comments&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;author&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;user&quot;</span>: [<br>          &#123;<br>            <span class="hljs-string">&quot;_id&quot;</span>: ObjectId(<span class="hljs-string">&quot;5a934e000102030405000003&quot;</span>),<br>            <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;frmachao@126.com&quot;</span>,<br>            <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;user1&quot;</span>,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;frmachao&quot;</span><br>          &#125;<br>        ]<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>附上演示地址：<a href="https://mongoplayground.net/p/aSKn8PhYXow">MongoDB playground</a></p><p>通过搜索引擎 检索 <code>mongodb</code>+ <code>array</code> + <code>lookup</code> 我找到了解决办法</p><p>在stack overflow上有个问题，跟我遇到的情况基本一样： <a href="https://stackoverflow.com/questions/63267126/mongodb-lookup-with-array">mongodb-lookup-with-array</a></p><blockquote><p>解决办法： 通过 <code>unwind</code> + <code>$group</code> 来做</p></blockquote><p>先将数组打平，然后执行 lookup 操作</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dts">&#123;<br>  $unwind: &#123;<br><span class="hljs-symbol">    path:</span> <span class="hljs-string">&quot;$child_comments&quot;</span>,<br><span class="hljs-symbol">    preserveNullAndEmptyArrays:</span> true,<br>    <br>  &#125;,<br>  <br>&#125;,<br>  &#123;<br>  $lookup: &#123;<br><span class="hljs-symbol">    from:</span> <span class="hljs-string">&quot;user&quot;</span>,<br><span class="hljs-symbol">    localField:</span> <span class="hljs-string">&quot;child_comments.author.user&quot;</span>,<br><span class="hljs-symbol">    foreignField:</span> <span class="hljs-string">&quot;id&quot;</span>,<br><span class="hljs-symbol">    as:</span> <span class="hljs-string">&quot;child_comments.author.user&quot;</span>,<br>    <br>  &#125;,<br>  <br>&#125;,<br></code></pre></td></tr></table></figure><p>最后 通过 <code>group</code> 重新生成数组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-variable">$group</span>: &#123;<br>    _id: <span class="hljs-string">&quot;<span class="hljs-variable">$_id</span>&quot;</span>,<br>    datumID: &#123;<br>      <span class="hljs-variable">$first</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$datumID</span>&quot;</span>,<br>      <br>    &#125;,<br>    html: &#123;<br>      <span class="hljs-variable">$first</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$html</span>&quot;</span><br>    &#125;,<br>    child_comments: &#123;<br>      <span class="hljs-variable">$push</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$child_comments</span>&quot;</span>,<br>      <br>    &#125;,<br>    <br>  &#125;,<br>  <br>&#125;,<br></code></pre></td></tr></table></figure><p>附上演示地址：<a href="https://mongoplayground.net/p/h3jwNQ0Yoxv">MongoDB playground</a></p><h3 id="数组中的字段不一定存在时-该如何判断"><a href="#数组中的字段不一定存在时-该如何判断" class="headerlink" title="数组中的字段不一定存在时 该如何判断"></a>数组中的字段不一定存在时 该如何判断</h3><p>因为我要统计每条父评论下一共有多少子评论,来实现子评论的分页查询操作，这个主要通过 $size操作符来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">$addFields: &#123;<br>child_total: &#123;<br>$size: <span class="hljs-string">&quot;$child_comments&quot;</span><br>&#125;,<br>&#125;,<br><br></code></pre></td></tr></table></figure><p>但是上面代码执行后的结果并不是我预期的，因为之前在做<code>lookup</code>操作时，如果 <code>child_comments</code>字段为空就会得到这样的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;_id&quot;</span>: ObjectId(<span class="hljs-string">&quot;5a934e000102030405000002&quot;</span>),<br>  <span class="hljs-string">&quot;child_comments&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;author&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;user&quot;</span>: []<br>      &#125;<br>    &#125;<br>  ],<br>  <span class="hljs-string">&quot;datumID&quot;</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-string">&quot;html&quot;</span>: <span class="hljs-string">&quot;这是父评论2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>显然像这样的话，<code>child_comments</code> 数组的长度就会跟实际子评论数量不同，所以在计算child_total 要额外判断。</p><p>一开始我使用 $type 操作符 在聚合操作中做判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;$addFields&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;child_total&quot;</span>: &#123;<br>      $type: <span class="hljs-string">&quot;$child_comments.author&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 得到 child_total 居然是 array</span><br></code></pre></td></tr></table></figure><p>翻阅文档后得知在聚合阶段 与$type根据 BSON 类型匹配数组元素的查询运算符不同，$type 聚合运算符不检查数组元素。相反，当传递一个数组作为其参数时，$type聚合运算符返回参数的类型，即”array”。</p><p>既然这样我就换种思路：</p><ol><li>先将计算 child_total 字段的操作提前到 数组 lookup 操作之前</li><li>在<code>group</code>操作重新生成数组时，对 <code>child_comments</code>做如下处理<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>$set: &#123;<br>child_comments: &#123;<br>$switch: &#123;<br>branches: [&#123;<br><span class="hljs-keyword">case</span>:<br>&#123;<br>$in:<br>[<span class="hljs-string">&quot;normal&quot;</span>, <span class="hljs-string">&quot;$child_comments.author.role&quot;</span>],<br>&#125;,<br>then: <span class="hljs-string">&quot;$child_comments&quot;</span>,<br>&#125;,<br>&#123;<br><span class="hljs-keyword">case</span>:<br>&#123;<br>$in:<br>[<span class="hljs-string">&quot;author&quot;</span>, <span class="hljs-string">&quot;$child_comments.author.role&quot;</span>],<br>&#125;,<br>then: <span class="hljs-string">&quot;$child_comments&quot;</span>,<br>&#125;,<br>],<br><span class="hljs-keyword">default</span>:<br>[],<br>&#125;,<br>&#125;,<br>&#125;,<br>&#125;,<br></code></pre></td></tr></table></figure>这样就能得到我想要的结构了，我们测试一下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123;<br>    <span class="hljs-string">&quot;_id&quot;</span>: ObjectId(<span class="hljs-string">&quot;5a934e000102030405000001&quot;</span>),<br>    <span class="hljs-string">&quot;child_comments&quot;</span>: [<br>      &#123;<br>        <span class="hljs-string">&quot;author&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;author&quot;</span>,<br>          <span class="hljs-string">&quot;user&quot;</span>: [<br>            &#123;<br>              <span class="hljs-string">&quot;_id&quot;</span>: ObjectId(<span class="hljs-string">&quot;5a934e000102030405000003&quot;</span>),<br>              <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;frmachao@126.com&quot;</span>,<br>              <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;user1&quot;</span>,<br>              <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;frmachao&quot;</span><br>            &#125;<br>          ]<br>        &#125;<br>      &#125;<br>    ],<br>    <span class="hljs-string">&quot;child_total&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;datumID&quot;</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;html&quot;</span>: <span class="hljs-string">&quot;这是父评论1&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;_id&quot;</span>: ObjectId(<span class="hljs-string">&quot;5a934e000102030405000002&quot;</span>),<br>    <span class="hljs-string">&quot;child_comments&quot;</span>: [],<br>    <span class="hljs-string">&quot;child_total&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;datumID&quot;</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;html&quot;</span>: <span class="hljs-string">&quot;这是父评论2&quot;</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure>附上演示地址：<a href="https://mongoplayground.net/p/RkZ2FNWbJl8">MongoDB playground</a></li></ol><h2 id="前端评论框实现"><a href="#前端评论框实现" class="headerlink" title="前端评论框实现"></a>前端评论框实现</h2><ul><li>Ant Design<ul><li>Comment 组件</li><li>Pagination 组件</li><li>Popconfirm 组件</li><li>Form 组件</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/dD1EER.png" alt="dD1EER"></p><ul><li>markdown-it Markdown 解析器<ul><li>精简版 Markdown 不支持 htm 标签解析<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mdParserComment = MarkdownIt(&#123;<br>    html: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不支持html嵌套</span><br>    linkify: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 支持url生成a链接</span><br>    typographer: <span class="hljs-literal">true</span>,<br>    highlight: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (lang &amp;&amp; hljs.getLanguage(lang)) &#123;<br>            <span class="hljs-keyword">return</span> hljs.highlight(str, &#123; <span class="hljs-attr">language</span>: lang &#125;).value;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// use external default escaping</span><br>    &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2></li></ul></li></ul><p>我的<a href="http://101.132.140.62/">个人网站</a>–》<a href="http://101.132.140.62/datum">知拾</a>—》<a href="http://101.132.140.62/datum/view?id=6131aa762237bc57827adaf5">评论</a> 欢迎大家使用。</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/zpqm2H.png" alt="zpqm2H"></p>]]></content>
    
    
    <categories>
      
      <category>代码人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
      <tag>mongodb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongodb 查询嵌入式文档数组比较某项字段的值</title>
    <link href="/posts/7d83f8b4/"/>
    <url>/posts/7d83f8b4/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>现在我有一个这样的 mongodb 文档模型 <code>Article</code></p><p><code>author、group</code> 这两个字段分别左外部联接 <code>User</code>和<code>ArticleGroup</code>两个集合</p><blockquote><p>我使用的是 mongoose 对象文档模型（ODM）库，集合名称都是大写的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> ArticleSchema = <span class="hljs-keyword">new</span> mongoose.Schema(&#123;<br>    title: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>    author: &#123; <span class="hljs-attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="hljs-attr">ref</span>: <span class="hljs-string">&quot;User&quot;</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>    group: &#123; <span class="hljs-attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="hljs-attr">ref</span>: <span class="hljs-string">&quot;ArticleGroup&quot;</span> &#125;,<br>&#125;);<br><span class="hljs-comment">// ArticleGroup</span><br><span class="hljs-keyword">const</span> ArticleGroupSchema = <span class="hljs-keyword">new</span> mongoose.Schema(&#123;<br>    name: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>    desc: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;&quot;</span> &#125;,<br>    state: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;public&quot;</span> &#125;,<br>    members: [<br>        &#123;<br>            desc: <span class="hljs-built_in">String</span>,<br>            role: <span class="hljs-built_in">String</span>,<br>            user: &#123; <span class="hljs-attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="hljs-attr">ref</span>: <span class="hljs-string">&quot;User&quot;</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>        &#125;,<br>    ],<br>&#125;);<br><span class="hljs-comment">// User</span><br><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> mongoose.Schema(<br>    &#123;<br>        email: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> &#125;,<br>        password: <span class="hljs-built_in">String</span>,<br>    &#125;,<br>);<br></code></pre></td></tr></table></figure><p>test data :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  _id: <span class="hljs-string">&quot;6131aa5b367318e2df14b988&quot;</span>,<br>  title: <span class="hljs-string">&quot;功能更新清单&quot;</span>,<br>  author: ObjectId(<span class="hljs-string">&quot;607edeb4b1e1bea9acb5af38&quot;</span>),<br>  group: ObjectId(<span class="hljs-string">&quot;612d00a43c52975d4ade10d4&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="我预期的结果"><a href="#我预期的结果" class="headerlink" title="我预期的结果"></a>我预期的结果</h2><p>我想在 aggregate 聚合操作内通过比较 author._id == group.members.user 的值，向文档添加一个新字段 can_edit。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"> Article.aggregate([<br>&#123;<br>  $lookup: &#123;<br>       <span class="hljs-keyword">from</span>: <span class="hljs-string">&quot;users&quot;</span>,<br>       localField: <span class="hljs-string">&quot;author&quot;</span>,<br>       foreignField: <span class="hljs-string">&quot;_id&quot;</span>,<br>       <span class="hljs-keyword">as</span>: <span class="hljs-string">&quot;author&quot;</span>,<br>     &#125;,<br> &#125;,<br>&#123;<br>    $lookup: &#123;<br>      <span class="hljs-keyword">from</span>: <span class="hljs-string">&quot;articlegroups&quot;</span>,<br>      localField: <span class="hljs-string">&quot;group&quot;</span>,<br>      foreignField: <span class="hljs-string">&quot;_id&quot;</span>,<br>      <span class="hljs-keyword">as</span>: <span class="hljs-string">&quot;group&quot;</span><br>    &#125;<br>&#125;,<br>  &#123;<br>     $addFields: &#123;<br>          can_edit: &#123;<br>                        $eq: [<span class="hljs-string">&quot;$group.members.user&quot;</span>, <span class="hljs-string">&quot;$author._id&quot;</span>],<br>                      &#125;,<br>                &#125;<br>  &#125;<br>])<br><br></code></pre></td></tr></table></figure><p>可是我得到的 can_edit 值始终是 false,我确定在我的测试数据中 author._id 的值和group.members.user 是相同。</p><p>期望返回的文档结构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  _id: <span class="hljs-string">&quot;6131aa5b367318e2df14b988&quot;</span>,<br>  can_edit: <span class="hljs-literal">true</span>,<br>  title: <span class="hljs-string">&quot;功能更新清单&quot;</span>,<br>  author: &#123;<br>    _id: <span class="hljs-string">&quot;607edeb4b1e1bea9acb5af38&quot;</span>,<br>    email: <span class="hljs-string">&quot;frmachao@126.com&quot;</span>,<br>    <br>  &#125;,<br>  group: &#123;<br>    _id: <span class="hljs-string">&quot;612d00a43c52975d4ade10d4&quot;</span>,<br>    desc: <span class="hljs-string">&quot;开发&quot;</span>,<br>    state: <span class="hljs-string">&quot;public&quot;</span>,<br>    name: <span class="hljs-string">&quot;开发小组&quot;</span>,<br>    members: [<br>      &#123;<br>        _id: <span class="hljs-string">&quot;612d00a43c52975d4ade10d5&quot;</span>,<br>        role: <span class="hljs-string">&quot;admin&quot;</span>,<br>        user: <span class="hljs-string">&quot;607edeb4b1e1bea9acb5af38&quot;</span>,<br>        <br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>刚刚，我找到一个相似的问题 <a href="https://stackoverflow.com/questions/46771145/querying-mongo-array-of-embedded-documents-in-aggregation-pipeline">stackoverflow</a>。上面提到： $eq (聚合)比较不同于查询 eq opeator 的值和类型，后者可以比较任何类型的值。需要 $in (聚合)来验证数组中的值</p><p>于是我尝试做了下面更改</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php">Article.aggregate([<br>&#123;<br>  <span class="hljs-variable">$lookup</span>: &#123;<br>       <span class="hljs-keyword">from</span>: <span class="hljs-string">&quot;users&quot;</span>,<br>       localField: <span class="hljs-string">&quot;author&quot;</span>,<br>       foreignField: <span class="hljs-string">&quot;_id&quot;</span>,<br>       <span class="hljs-keyword">as</span>: <span class="hljs-string">&quot;author&quot;</span>,<br>     &#125;,<br> &#125;,<br>&#123;<br>    <span class="hljs-variable">$lookup</span>: &#123;<br>      <span class="hljs-keyword">from</span>: <span class="hljs-string">&quot;articlegroups&quot;</span>,<br>      localField: <span class="hljs-string">&quot;group&quot;</span>,<br>      foreignField: <span class="hljs-string">&quot;_id&quot;</span>,<br>      <span class="hljs-keyword">as</span>: <span class="hljs-string">&quot;group&quot;</span><br>    &#125;<br>&#125;,<br>  &#123;<br>    <span class="hljs-variable">$addFields</span>: &#123;<br>      can_edit: &#123;<br>        <span class="hljs-variable">$in</span>: [<br>          <span class="hljs-string">&quot;<span class="hljs-subst">$author</span>._id&quot;</span>,<br>          <span class="hljs-string">&quot;<span class="hljs-subst">$group</span>.members.user&quot;</span><br>        ],<br>      &#125;,<br>    &#125;,<br>  &#125;<br>])<br><br></code></pre></td></tr></table></figure><p>但是遇到了新问题： <code>$in requires an array as a second argument</code></p><p>在挣扎了100分钟: 尝试用搜索引擎检索我遇到的问题、去翻阅<code>$eq聚合阶段</code>的文档、咨询微信里做过服务端开发的网友</p><p>可是问题还是没有解决，最后我决定去社区提问。</p><h2 id="去社区提问"><a href="#去社区提问" class="headerlink" title="去社区提问"></a>去社区提问</h2><ol><li>国内 <a href="https://segmentfault.com/q/1010000040631179">segmentfault</a></li><li>国外的 <a href="https://stackoverflow.com/questions/46771145/querying-mongo-array-of-embedded-documents-in-aggregation-pipeline">stackoverflow</a><h2 id="mongoplayground"><a href="#mongoplayground" class="headerlink" title="mongoplayground"></a>mongoplayground</h2></li></ol><p>stackoverflow 上面，一位热心的马来西亚程序员帮我解决了问题:<br>他告诉我 应该 <code>group.members must be array checking</code>，也就是先要判断group.members 是不是一个数组。</p><p>分析：在我定义的数据模型里，group 并不是一个必填项，所以 group 字段可能为空</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ArticleSchema = <span class="hljs-keyword">new</span> mongoose.Schema(&#123;<br>    title: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>    author: &#123; <span class="hljs-attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="hljs-attr">ref</span>: <span class="hljs-string">&quot;User&quot;</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> &#125;,<br>    group: &#123; <span class="hljs-attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="hljs-attr">ref</span>: <span class="hljs-string">&quot;ArticleGroup&quot;</span> &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>热情的马来西亚程序员 甚至给出了完整的 判断 group.members must be array 的样例，附上调试地址，respect！！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js">db.collection.aggregate([<br>  &#123;<br>    $addFields: &#123;<br>      can_edit: &#123;<br>        $switch: &#123;<br>          branches: [<br>            &#123;<br>              <span class="hljs-keyword">case</span>: &#123;<br>                $ne: [<br>                  &#123;<br>                    <span class="hljs-string">&quot;$type&quot;</span>: <span class="hljs-string">&quot;$group.members&quot;</span><br>                  &#125;,<br>                  <span class="hljs-string">&quot;array&quot;</span><br>                ]<br>              &#125;,<br>              then: <span class="hljs-literal">false</span><br>            &#125;,<br>            &#123;<br>              <span class="hljs-keyword">case</span>: &#123;<br>                $ne: [<br>                  &#123;<br>                    <span class="hljs-string">&quot;$type&quot;</span>: <span class="hljs-string">&quot;$group.members&quot;</span><br>                  &#125;,<br>                  <span class="hljs-string">&quot;array&quot;</span><br>                ]<br>              &#125;,<br>              then: <span class="hljs-literal">false</span><br>            &#125;,<br>            &#123;<br>              <span class="hljs-keyword">case</span>: &#123;<br>                $in: [<br>                  <span class="hljs-string">&quot;$author._id&quot;</span>,<br>                  <span class="hljs-string">&quot;$group.members.user&quot;</span><br>                ]<br>              &#125;,<br>              then: <span class="hljs-literal">true</span><br>            &#125;<br>          ],<br>          <span class="hljs-keyword">default</span>: <span class="hljs-literal">false</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>])<br></code></pre></td></tr></table></figure><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol><li><a href="https://mongoplayground.net/">mongoplayground</a>一个网站 可以在线调试 mongoDB的查询</li><li>$eq (聚合)比较不同于查询 eq opeator 的值和类型，后者可以比较任何类型的值。需要 $in (聚合)来验证数组中的值。</li><li>去社区提问需要注意：描述清楚自己的问题，不要带上自己的业务细节把问题剥离出来，最好能提供一个在线运行的<code>playground</code>。</li></ol><h2 id="🤔思考"><a href="#🤔思考" class="headerlink" title="🤔思考"></a>🤔思考</h2><ol><li>自学能力差： 为什么我翻看文档时没有看到 <code>$eq (聚合)比较不同于查询 eq opeator 的值和类型，后者可以比较任何类型的值。需要 $in (聚合)来验证数组中的值</code></li><li>英语很差：stackoverflow 上编写的提问描述全部来自 google 翻译 中–》英</li></ol>]]></content>
    
    
    <categories>
      
      <category>代码人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
      <tag>mongodb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录react+node+mongodb项目部署到服务器的过程</title>
    <link href="/posts/7c957dfb/"/>
    <url>/posts/7c957dfb/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我之前只做过web前端开发，对服务器相关的东西是纯小白，这篇文章仅用来记录学习。</p><h2 id="常用Linux命令"><a href="#常用Linux命令" class="headerlink" title="常用Linux命令"></a>常用Linux命令</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> 进入目录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span> 返回上一个目录<br><span class="hljs-keyword">ls</span> -a 查看当前目录<br>mkdir abc 创建abc文件夹<br>mv 移动或重命名<br>rm 删除一个文件<br>rm -rf 递归删除指定文件夹<br>关机命令：<span class="hljs-keyword">shutdown</span>或poweroff<br><span class="hljs-keyword">shutdown</span><span class="hljs-function">:shutdown</span> -h now  <span class="hljs-comment">#立即关机（shutdown -h 10   #10分钟后关机）</span><br>poweroff：直接输入poweroff 即可<br>重启命令：<span class="hljs-keyword">shutdown</span>或reboot<br><span class="hljs-keyword">shutdown</span><span class="hljs-function">:shutdown</span> -r now  <span class="hljs-comment">#立即重新启动  （shutdown -r +10  #10分钟之后重启）</span><br>reboot：直接输入即可。<br></code></pre></td></tr></table></figure><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>我的服务器信息：</p><ul><li>阿里云轻量服务器：2G运行内存 2核 60G硬盘 1000G流量/月 </li><li>镜像信息: CentOS 7.3</li><li>公网 IP: <a href="http://101.132.140.62/">http://101.132.140.62</a></li><li>备案后才可以使用80端口访问域名</li><li>我没有备案 暂时通过公网 IP 访问 </li></ul><h2 id="SSH-连接到服务器"><a href="#SSH-连接到服务器" class="headerlink" title="SSH 连接到服务器"></a>SSH 连接到服务器</h2><ol><li>在阿里云的工作台 使用浏览器发起安全连接（推荐）</li><li>客户端使用账号密码进行连接 (在阿里云后台设置密码后，在电脑终端执行 ssh <a href="mailto:&#114;&#x6f;&#111;&#x74;&#x40;&#x31;&#48;&#49;&#x2e;&#49;&#x33;&#50;&#46;&#49;&#52;&#48;&#46;&#x36;&#50;">&#114;&#x6f;&#111;&#x74;&#x40;&#x31;&#48;&#49;&#x2e;&#49;&#x33;&#50;&#46;&#49;&#52;&#48;&#46;&#x36;&#50;</a> 根据提示输入密码)<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/6SByfM.png" alt="6SByfM"></li></ol><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>先安装nvm 然后 通过nvm 安装跟本地开发环境一样的nodejs 版本</p><ol><li><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash</code></li><li><code>source ~/.bashrc</code></li><li><code>nvm install 12.16.1</code> （安装的第一个版本成为默认版本）</li></ol><h2 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h2><p>参考: <a href="https://jasonkayzk.github.io/2021/03/10/CentOS7%E5%AE%89%E8%A3%85MongoDB/">https://jasonkayzk.github.io/2021/03/10/CentOS7%E5%AE%89%E8%A3%85MongoDB/</a></p><blockquote><p> 还是要跟着官方文档走，有人写得博客内容可能已经过时，或者作者得内容本身就有问题.</p></blockquote><ol><li><p>创建/etc/yum.repos.d/MongoDB-enterprise-4.4. repo 文件，这样您就可以直接使用 yum</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[mongodb-enterprise-4.4]<br>name=MongoDB Enterprise Repository<br>baseurl=https://repo.mongodb.com/yum/redhat/<span class="hljs-variable">$releasever</span>/mongodb-enterprise/4.4/<span class="hljs-variable">$basearch</span>/<br>gpgcheck=1<br>enabled=1<br>gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc<br><br></code></pre></td></tr></table></figure><p>注释</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">name <span class="hljs-comment"># 名称</span><br>baseurl <span class="hljs-comment"># 获得下载的路径</span><br>gpkcheck=1 <span class="hljs-comment"># 表示对从这个源下载的rpm包进行校验；</span><br>enable=1 <span class="hljs-comment"># 表示启用这个源</span><br>gpgkey <span class="hljs-comment"># gpg验证</span><br></code></pre></td></tr></table></figure></li><li><p><code>sudo yum install -y mongodb-enterprise</code></p></li><li><p>验证安装结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">执行： rpm -qa |grep mongodb<br>输出:<br>mongodb-enterprise-server-4.4.8-1.el7.x86_64<br>mongodb-enterprise-tools-4.4.8-1.el7.x86_64<br>mongodb-enterprise-database-tools-extra-4.4.8-1.el7.x86_64<br>mongodb-enterprise-4.4.8-1.el7.x86_64<br>mongodb-enterprise-shell-4.4.8-1.el7.x86_64<br>mongodb-enterprise-mongos-4.4.8-1.el7.x86_64<br>mongodb-database-tools-100.5.0-1.x86_64<br>mongodb-enterprise-cryptd-4.4.8-1.el7.x86_64<br></code></pre></td></tr></table></figure></li><li><p>启动MongoDB服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start mongod.service<br></code></pre></td></tr></table></figure></li><li><p>验证服务开启</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">执行: mongo<br>输出： MongoDB <span class="hljs-keyword">shell</span> <span class="hljs-keyword">version</span> v4.<span class="hljs-number">4.8</span><br>connecting <span class="hljs-keyword">to</span>: mongod<span class="hljs-variable">b:</span>//<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">27017</span>/?compressors=disabled&amp;gssapiServiceName=mongodb<br></code></pre></td></tr></table></figure><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2></li></ol><blockquote><p>参考:<a href="https://juejin.cn/post/6844904134345228301">https://juejin.cn/post/6844904134345228301</a></p></blockquote><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum -y install nginx   <span class="hljs-comment"># 安装 nginx</span><br>sudo yum remove nginx  <span class="hljs-comment"># 卸载 nginx</span><br></code></pre></td></tr></table></figure><p>使用 yum 进行 Nginx 安装时，Nginx 配置文件在 /etc/nginx 目录下。<br>配置Nginx 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl <span class="hljs-built_in">enable</span> nginx <span class="hljs-comment"># 设置开机启动 </span><br>$ sudo service nginx start <span class="hljs-comment"># 启动 nginx 服务</span><br>$ sudo service nginx stop <span class="hljs-comment"># 停止 nginx 服务</span><br>$ sudo service nginx restart <span class="hljs-comment"># 重启 nginx 服务</span><br>$ sudo service nginx reload <span class="hljs-comment"># 重新加载配置，一般是在修改过 nginx 配置文件时使用</span><br><br></code></pre></td></tr></table></figure><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><blockquote><p>参考: <a href="https://segmentfault.com/a/1190000023077588">https://segmentfault.com/a/1190000023077588</a></p></blockquote><h2 id="安装-npm-依赖"><a href="#安装-npm-依赖" class="headerlink" title="安装 npm 依赖"></a>安装 npm 依赖</h2><h3 id="在使用npm-install-的时候提示-core-js-pure-postinstall-执行出错"><a href="#在使用npm-install-的时候提示-core-js-pure-postinstall-执行出错" class="headerlink" title="在使用npm install 的时候提示 core-js-pure postinstall 执行出错"></a>在使用npm install 的时候提示 core-js-pure postinstall 执行出错</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">core-js-pure@3.6.5 postinstall: `node -e <span class="hljs-string">&quot;try&#123;require(&#x27;./postinstall&#x27;)&#125;catch(e)&#123;&#125;&quot;</span>`<br>npm ERR! spawn ENOENT<br>npm ERR! <br>npm ERR! Failed at the core-js-pure@3.6.5 postinstall script.<br>npm ERR! This is probably not a problem with npm. There is likely additional logging output above.<br></code></pre></td></tr></table></figure><p>解决方式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i --unsafe-perm<br></code></pre></td></tr></table></figure><p>原因：</p><p>npm 出于安全考虑不支持以 root 用户运行，即使你用 root 用户身份运行了，npm 会自动转成一个叫 nobody 的用户来运行，而这个用户几乎没有任何权限。这样的话如果你脚本里有一些需要权限的操作，比如写文件（尤其是写 /root/.node-gyp），就会崩掉了。</p><p>为了避免这种情况，要么按照 npm 的规矩来，专门建一个用于运行 npm 的高权限用户；要么加 –unsafe-perm 参数，这样就不会切换到 nobody 上，运行时是哪个用户就是哪个用户，即使是 root。</p><p>权限不足报错时使用npm的姿势：<br>sudo + 命令 + –unsafe-perm</p><p>emmmm….</p><h3 id="在国内加速-npm-安装依赖的"><a href="#在国内加速-npm-安装依赖的" class="headerlink" title="在国内加速 npm 安装依赖的"></a>在国内加速 npm 安装依赖的</h3><p>在项目根目录 创建<code>.npmrc</code>文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 配置淘宝的 npm 镜像源</span><br>registry=https:<span class="hljs-regexp">//</span>registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h2 id="前端构建环境"><a href="#前端构建环境" class="headerlink" title="前端构建环境"></a>前端构建环境</h2><ol><li>babel+ webpack 构建时报错：Can’t resolve ‘regenerator-runtime/runtime’<blockquote><p>参考：<a href="https://stackoverflow.com/questions/58919016/babel-and-webpack-are-throwing-cant-resolve-regenerator-runtime-runtime">https://stackoverflow.com/questions/58919016/babel-and-webpack-are-throwing-cant-resolve-regenerator-runtime-runtime</a></p></blockquote></li></ol><p>之前构建是正常的啊，奇怪…可能后面项目中用到了什么新语法吧</p><blockquote><p>注意我项目中的<code>babel</code>版本是7.9</p></blockquote><p>解决：只需运行 npm i regenerator-runtime 就可以修复它，<br>去看了 babel 官网关于<a href="https://babeljs.io/docs/en/babel-preset-env">useBuiltIns</a> 这个配置项，是这样描述的:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">useBuiltIns: <span class="hljs-string">&#x27;entry&#x27;</span><br><br>&gt; Only use <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;core-js&quot;</span>; and <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;regenerator-runtime/runtime&quot;</span>;<br> 只使用导入“ core-js”; 导入“ regenerator-<span class="hljs-keyword">runtime</span>/<span class="hljs-keyword">runtime</span>”; 在整个应用程序中只使用一次<br></code></pre></td></tr></table></figure><p>说实话我没读懂…</p><ol start="2"><li>gifsicle pre-build test failed</li></ol><p>参考：<a href="https://github.com/frmachao/frmachao.github.io/issues/8">记 gulp-imagemin 安装时遇到的问题</a></p><h2 id="ngix-代理请求到-express-并开启gzip"><a href="#ngix-代理请求到-express-并开启gzip" class="headerlink" title="ngix 代理请求到 express 并开启gzip"></a>ngix 代理请求到 express 并开启gzip</h2><ul><li>我的配置文件路径是<code>/etc/nginx/nginx.conf</code></li><li>我的express 运行的端口是 3000</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    gzip         on;<br>    listen       80;<br>    listen       [::]:80;<br>    server_name  _;<br>    root         /usr/share/nginx/html;<br><br>    <span class="hljs-comment"># Load configuration files for the default server block.</span><br>    include /etc/nginx/default.d/*.conf;<br>    location / &#123;<br>     proxy_pass    http://localhost:3000;<br>    &#125;<br><br>    error_page 404 /404.html;<br>    location = /404.html &#123;<br>    &#125;<br><br>    error_page 500 502 503 504 /50x.html;<br>    location = /50x.html &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改配置文件后 执行<code>sudo service nginx reload</code></p><h2 id="SEO-robots-txt文件配置"><a href="#SEO-robots-txt文件配置" class="headerlink" title="SEO robots.txt文件配置"></a>SEO robots.txt文件配置</h2><p>起因：查看服务器日志发现不断有人有请求/robots.txt</p><p>查询后得知 robots.txt 文件规定了搜索引擎抓取工具可以访问您网站上的哪些网址。 此文件主要用于避免您的网站收到过多请求；</p><p>robots.txt 文件中的以下指令:</p><ol><li>user-agent: [必需，每个组需含一个或多个 User-agent 条目] 该指令指定了规则适用的自动客户端（即搜索引擎抓取工具）的名称。这是每个规则组的首行内容.</li><li>disallow: [每条规则需含至少一个或多个 disallow 或 allow 条目] 您不希望用户代理抓取的目录或网页（相对于根网域而言）。</li><li>allow: [每条规则需含至少一个或多个 disallow 或 allow 条目] 上文中提到的用户代理可以抓取的目录或网页（相对于根网域而言）。</li><li>itemap: [可选，每个文件可含零个或多个 sitemap 条目] 相应网站的站点地图的位置。站点地图网址必须是完全限定的网址</li></ol><blockquote><p>参考：<a href="https://developers.google.com/search/docs/advanced/robots/intro?hl=zh-cn">robots.txt 简介</a></p></blockquote><p>这是我的 robots.txt ：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts">User-agent: *<br><span class="hljs-symbol">Disallow:</span> <span class="hljs-meta-keyword">/admin/</span><br><span class="hljs-symbol">Disallow:</span> <span class="hljs-meta-keyword">/manage/</span><br><span class="hljs-symbol">Disallow:</span> <span class="hljs-meta-keyword">/ajax/</span><br><span class="hljs-symbol">Disallow:</span> <span class="hljs-meta-keyword">/graphql/</span><br><span class="hljs-symbol">Disallow:</span> <span class="hljs-meta-keyword">/auth/</span><br><span class="hljs-symbol">Disallow:</span> <span class="hljs-meta-keyword">/api/</span><br><span class="hljs-symbol">Disallow:</span> <span class="hljs-meta-keyword">/account/</span><br><span class="hljs-symbol">Disallow:</span> *.php<br><span class="hljs-symbol">Disallow:</span> *.asp<br><span class="hljs-symbol">Disallow:</span> *.aspx<br></code></pre></td></tr></table></figure><h2 id="使用PM2部署项目"><a href="#使用PM2部署项目" class="headerlink" title="使用PM2部署项目"></a>使用PM2部署项目</h2><blockquote><p>什么是PM2: PM2 是一个守护进程管理器，它将帮助您管理和保持您的应用程序在线</p></blockquote><p>快速使用：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install pm2@latest -g<br>pm2 start app.js<br></code></pre></td></tr></table></figure><p>我在项目中的使用: 在项目根目录下新建一个 <code>pm2_start.sh</code> 文件，每次提交后项目后，再服务器环境中执行 <code>sh pm2_start.sh</code></p><p>Todo: 我的这种不是好的部署方式</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;拉取git仓库&quot;</span><br>git pull<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;安装前端项目依赖&quot;</span><br>npm i <span class="hljs-params">--unsafe-perm</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;安装后端项目依赖&quot;</span><br><span class="hljs-keyword">cd</span> server/ &amp;&amp; npm i <span class="hljs-params">--unsafe-perm</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;构建前端&quot;</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">../</span> &amp;&amp; npm run build <span class="hljs-params">--unsafe-perm</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;构建后端&quot;</span><br><span class="hljs-keyword">cd</span> server &amp;&amp; npm run build <span class="hljs-params">--unsafe-perm</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;杀掉所有pm2&quot;</span><br>pm2 kill<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;pm2 启动 node 程序&quot;</span><br>NODE_ENV=production pm2 start dist/app.js<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;设置 centos 开机启动 pm2&quot;</span><br>pm2 startup<br>pm2 save<br></code></pre></td></tr></table></figure><h2 id="后端构建遇到的问题："><a href="#后端构建遇到的问题：" class="headerlink" title="后端构建遇到的问题："></a>后端构建遇到的问题：</h2><h3 id="Command-failed-bin-sh-c-autoreconf-ivf-gifsicle-postinstall"><a href="#Command-failed-bin-sh-c-autoreconf-ivf-gifsicle-postinstall" class="headerlink" title="Command failed: /bin/sh -c autoreconf -ivf gifsicle postinstall"></a><code>Command failed: /bin/sh -c autoreconf -ivf gifsicle postinstall</code></h3><p>原因：We are using imagemin-gifsicle and therefore gifsicle-bin as part of our build. With the release 5.0.0, the linux bin files got removed. As consequence of that removal, our build does not work anymore on the CI Server. (The build tries to rebuild gifcicle and misses autoreconf for that..)</p><p>解决方式: </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Linux:<br>sudo apt-<span class="hljs-keyword">get</span> install libtool <span class="hljs-built_in">auto</span>make <span class="hljs-built_in">auto</span>conf nasm<br><span class="hljs-comment">// centos 上 使用 yum 来安装: sudo yum install libtool automake autoconf nasm</span><br>OS X:<br>brew install libtool <span class="hljs-built_in">auto</span>make <span class="hljs-built_in">auto</span>conf nasm<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务端部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客 SEO 优化</title>
    <link href="/posts/df28a7c5/"/>
    <url>/posts/df28a7c5/</url>
    
    <content type="html"><![CDATA[<h2 id="配置站点地图"><a href="#配置站点地图" class="headerlink" title="配置站点地图"></a>配置站点地图</h2><ul><li>通过 hexo-generator-sitemap 插件生成站点地图 </li><li><a href="https://blog.frmachao.top/sitemap.xml">https://blog.frmachao.top/sitemap.xml</a><h2 id="配置-robots-txt-文件"><a href="#配置-robots-txt-文件" class="headerlink" title="配置 robots.txt 文件"></a>配置 robots.txt 文件</h2></li><li>网站根目录添加 robots.txt 文件</li><li><a href="https://blog.frmachao.top/robots.txt">https://blog.frmachao.top/robots.txt</a><h2 id="谷歌收录"><a href="#谷歌收录" class="headerlink" title="谷歌收录"></a>谷歌收录</h2>在 <a href="https://search.google.com/">search.google.com</a> 中使用<code>html 标记</code>的方式分别收录了 <code>blog.frmachao.top</code> 和 <code>frmachao.top</code> 两个站点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2023-04-09-2xHj0F.png" alt="html标记收录"></p><p>主动提交站点地图</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2023-04-09-OwcxWJ.png" alt="提交站点地图"></p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录从食指伸肌腱手术后甲根长期感染不愈合到二次手术的过程</title>
    <link href="/posts/9d3837ea/"/>
    <url>/posts/9d3837ea/</url>
    
    <content type="html"><![CDATA[<blockquote><p>多图预警： 本文中含有大量手指流血感染的图片，可能会引起读者生理性不适</p></blockquote><p><strong>先说个人结论：</strong><br>在人均医疗资源紧缺的背景下：大型医院的医生往往以手术为导向，对于不需要手术的病人，往往几句消毒注意卫生就打发走了病人，甚至没有体格检查这类会占用医生宝贵门诊时间的行为。</p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p><strong>2021年3月份</strong>在四川成都的 <a href="http://scxdyy.com/">四川现代医院</a> 接受了食指伸肌腱键帽修复，3月5号手术，住院5天，术后石膏固定3天，然后换成支具固定。（3月5号手术的原因我会单独写一篇文章来记录，只能说是一次惨痛的教训）</p><p>术后第三天拆石膏我感觉是食指甲根处有些肿痛（下图），于是询问了查房医生，医生看后说没有问题过几天就好了。</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/VQE2wm.jpg" alt="VQE2wm"></p><p><strong>2021年3月30号 手术后25天</strong> 拆除支具 （下图）发现甲根处开始红肿指甲没有生长痕迹，按压感觉刺痛，当天去医院门诊找医生检查，医生告知自己没有在临床遇到过，但是推测是真菌感染甲根，让我回家注意卫生多观察，定期来医院复查。</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/h5ncYE.jpg" alt="h5ncYE"></p><p><strong>2021年4月15号 手术41天</strong> 指甲开始生长，但是甲根处红肿加具。去医院询问手术医生，答复依然是注意手部卫生。现在回想 医生是不是没有上心去处理呢，还是说这时真的没什么好处理的，只能注意卫生？</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/Al01Cp.jpg" alt="Al01Cp"></p><p><strong>2021年5月5日 手术后61天</strong> 甲根处开始有淡黄色液体渗出（下图），这时我已经离开成都返回徐州。微信在线咨询手术医生，医生这时建议拔甲治疗，但是我不想再对手指造成伤害（拔甲要切开周围皮肤，拔除后重新生长的过程也很痛苦），我决定继续保守治疗。去了当地医院手外科门诊，被告知只需要每天用碘伏浸泡一会即可，尽量不要碰到水，或者碰水后立刻消毒。</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/BUMbLd.jpg" alt="BUMbLd"></p><p><strong>2021年5月15号 术后71天</strong> 每天消毒避免患处碰水，坚持了10天发现情况在不断恶化，便去了当地三甲医院 <a href="https://www.xzch.cn/">徐州市第四人民医院</a> 就诊。我记得当时特意挂的专家门诊，大概4点临近下班去了诊室。</p><p>我：“医生，我这手指头在手术后一直红肿，术后一个月后开始渗出液体“</p><p>门诊医生：“哦，你先拍个彩超“</p><p>我：“医生您不做个体格检查，先看看嘛，你看我这甲根处按压会有液体流出，您能不能告诉我这是什么疾病”</p><p>门诊医生：“你别这跟我唠叨了，你快去做检查，不然待会就下班了”</p><p>我：“医生你为什么催我，现在也没有其他病人（此时诊室只有我跟医生两个人，外面也没有候诊的病人）”</p><p>不愉快后，去排队做了彩超检查，做完立即出来报告。我拿着报告去诊室找医生，结果医生提前溜回病房了，我赶忙跑去病房，找到医生。<br>医生看完报告说：“下面长了个囊肿，你准备办住院手术吧”</p><p>我：？？？ 手术？囊肿？心想指甲根哪里来的囊肿，主要这医生给我的感觉很差，我借口说回家想想，便离开了医院</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/x9Tmi4.jpg" alt="x9Tmi4"></p><p><strong>第二天 5月16 日</strong>，去了当地一家手外伤见长的专科医院 <a href="http://www.xzrcyy.com/">徐州仁慈医院</a> 同样是专家门诊。简单告知病情后，医生淡淡的说：“当时打石膏了吧，打石膏后就容易出现这种情况，你每天用酒精泡泡，要是严重了再过来”，话音刚落 医生就叫了下一位候诊的病人过来。</p><p><strong>5月17日</strong> 我又去了 当地另外一家三甲医院 <a href="http://www.xzzlyy.com/">徐州市肿瘤医院</a> ，同样是某某专家主任，这位医生也是说用酒精浸泡 每次浸泡10分钟。这次我突然感觉有希望了，两个医生给的方法一样，但是没想到这并不是正确的方式。<br>2021年 5月30号 指甲继续恶化，开始流血水。</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/8QqkwE.jpg" alt="8QqkwE"></p><p>到这里，我在当地一共去了四次医院，指甲的情况一次比一次恶化，但是没有一位门诊医生给我的手指做清创包扎处理。</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/4O2vx9.jpg" alt="4O2vx9"></p><p><strong>在2021年6月12号</strong> 手指不断恶化开始有脓流出，我去了医院急诊。转折来了，急诊医生叫来手外科医生会诊，帮我我清理了伤口进行包扎，并开了两天的抗生素静脉注射。医生叮嘱，第一周每天换一次药，第二周三天换一次药，两周后如果还没有愈合去病房找他，我仿佛抓到了救命稻草，赶紧加了医生微信。</p><p>6月13号换药后:</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/8db10C.jpg" alt="8db10C"></p><p><strong>2021年6月28日 手术后115天</strong>不幸的是，两周后手指依然没有愈合，去医院办理了住院，手术前医生给采集了伤口部分组织送去做细菌培养。6月28日下午 手术…. 指甲最终没有保住，两侧切开后</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/A2f4mK.jpg" alt="A2f4mK"><br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/sru5is.jpg" alt="sru5is"></p><p>手术后在病房住院一周，前三天医生给予抗生素静脉注射，但我头孢皮试过敏，于是选用了青霉素类药物。</p><p>手术后第一次换药：体会到了“十指连心”，失去了指甲的位置及其敏感，痛到脚软流汗。</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/qumxhw.jpg" alt="qumxhw"></p><p>好在第二次换药时医生用一块油纱盖在了指甲上，此后的换药就没那么痛苦了，所以现在回忆起来决定好像也没有那么痛苦。后来知道 这种心理被诺贝尔奖得主 丹尼尔·卡尼曼（Daniel Kahneman）叫 <a href="https://baike.baidu.com/item/%E5%B3%B0%E7%BB%88%E5%AE%9A%E5%BE%8B/6345450">“峰终定律（Peak-End rule）“</a>，即只计算在两个时刻体验到的平均疼痛，即过程中最糟糕的一个时刻和最后时刻。</p><p>“人好像有两个不同的自我：体验的自我平等地忍受每时每刻的体验，而记忆的自我事后几乎把全部的判断权重放在两个时刻上，即最糟糕的时刻和最后的时刻。即便在结果异常的情况下，记忆的自我也似乎坚持峰终定律。即便刚刚经受了半个多小时的高水平疼痛，只要在医疗过程结束时有那么几分钟不痛，病人对总体疼痛的评价就会戏剧性地降低。“</p><blockquote><p>覆盖在指头上的油纱</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/DaYgei.jpg" alt="DaYgei"></p><p>三天后细菌培养的报告出来，没有感染特别的细菌，同时三天的青霉素注射也让手指的炎症得以控制没有出现术后感染。事情似乎再往好的方向发展，但是这时有了新的问题：X 光影像报告显示手指骨密度异常！！</p><p><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/7Bhd5e.jpg" alt="7Bhd5e"></p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>健康</tag>
      
      <tag>手术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次node爬虫经历</title>
    <link href="/posts/332c06cc/"/>
    <url>/posts/332c06cc/</url>
    
    <content type="html"><![CDATA[<h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><ul><li>访问网站</li><li>获取列表页数据</li><li>循环列表页数据获取每条数据对应的详情页数据<ul><li>机构名称</li><li>机构类型</li><li>机构性质</li><li>联系人</li><li>固定电话</li><li>联系电话</li><li>联系地址</li></ul></li><li>导出 excel</li></ul><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>Mac OS v10.15.7</li><li>node v12.16.1</li><li>用到 npm 包</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;dependencies&quot;: &#123;<br>  &quot;async&quot;: &quot;^3.2.0&quot;,<br>  &quot;cheerio&quot;: &quot;^1.0.0-rc.5&quot;,<br>  &quot;json2xls&quot;: &quot;^0.1.2&quot;,<br>  &quot;nodemon&quot;: &quot;^2.0.7&quot;,<br>  &quot;puppeteer-core&quot;: &quot;^8.0.0&quot;,<br>  &quot;request&quot;: &quot;^2.88.2&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>cheerio 学习操作语法 基本跟 jQuery 一致</li><li>request 请求模块的基本使用</li><li>puppeteer 无头浏览器的基本使用</li><li>node fs 文件模块的基本使用</li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题:"></a>遇到的问题:</h2><h3 id="页面中的数据是-ajax-加载出来的"><a href="#页面中的数据是-ajax-加载出来的" class="headerlink" title="页面中的数据是 ajax 加载出来的"></a>页面中的数据是 ajax 加载出来的</h3><p>刚开始使用 request 直接请求页面，发现响应回来的 html 文档并不是完整的，页面上有 ajax 请求，动态生成了一部分 DOM , 我原本想分析它这个 ajax 请求的接口，发现请求地址上有个查询字符串,像这样：<br><code>?ajaxtype=yanglaoxx_showlianxi&amp;rand=0.17592822223231708</code><br>不懂这个 rand 值是怎么计算出来的，实在不想再去扒网站 js 的代码，于是想到用无头浏览器来渲染完整网页；</p><p>这里我使用 puppeteer 渲染完整的网页</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> page.goto(url, &#123;<br>  waitUntil: <span class="hljs-string">&quot;networkidle0&quot;</span>, <span class="hljs-comment">// 等待网页上所有网络请求结束</span><br>&#125;);<br><span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> page.content();<br>fs.writeFileSync(<span class="hljs-string">&quot;./loacl.html&quot;</span>, html); <span class="hljs-comment">// 将 puppeteer 请求回来的页面另存为本地的html文件，方便查看页面是否完整</span><br></code></pre></td></tr></table></figure><p>我只安装了 <code>puppeteer-core</code> 核心，使用 <code>puppeteer-core</code>需要手动指定已安装的 <code>Chrome </code>浏览器的安装路径。<br><code>Mac</code>电脑上<code>Chrome</code>浏览器的的安装路径，可以通过在浏览器中输入 <code>chrome:\\version</code> 来查看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.launch(&#123;<br>  executablePath:<br>    <span class="hljs-string">&quot;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&quot;</span>,<br>  headless: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// args: [ &#x27;--proxy-server=http://188.166.215.141:3128&#x27; ] // 用你的有效代理服务器替换</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>这是 puppeteer 返回的完整 html 结构，包含了 ajax 请求动态生成的 DOM 结构:<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/4YZvCU.jpg" alt="4YZvCU"></p><p>我现在遇到一个问题：在 puppeteer 中使用 cheerio 解析 html 文档 和 在浏览器使用 jquery 的表现不同。</p><p>疑问： 这两种 dom 选择有区别吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;#ContactUs &gt; .leftcontext:eq(0)  &gt; .leftcontexttitle:eq(3)&quot;</span>).text(); <span class="hljs-comment">// cheerio 解析不到,浏览器中 jquery 可以正常执行</span><br>$(<span class="hljs-string">&quot;#ContactUs &gt; .leftcontext:eq(0)&quot;</span>).children(<span class="hljs-string">&quot;.leftcontexttitle:eq(3)&quot;</span>).text(); <span class="hljs-comment">//  cheerio 解析成功</span><br></code></pre></td></tr></table></figure><h3 id="网站反爬"><a href="#网站反爬" class="headerlink" title="网站反爬"></a>网站反爬</h3><p>遇到 <code>pyppeteer.errors.TimeoutError: Navigation Timeout Exceeded: 30000 ms exceeded</code><br>爬取详情页时，访问次数多了 puppeteer 就会报错响应超时 我的思路是让 puppeteer 打开页面前等待 3-10 秒,同时让 puppeteer 等待网站响应的时间无限长</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sleep = <span class="hljs-function">(<span class="hljs-params">time</span>) =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      resolve(<span class="hljs-literal">true</span>);<br>    &#125;, time);<br>  &#125;);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandom</span>(<span class="hljs-params">n, m</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (m - n + <span class="hljs-number">1</span>) + n);<br>  <span class="hljs-keyword">return</span> num;<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-keyword">await</span> sleep(getRandom(<span class="hljs-number">3000</span>, <span class="hljs-number">10000</span>));<br><span class="hljs-keyword">await</span> page.goto(url, &#123;<br>  waitUntil: <span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-comment">// 这里设置成 load 和 networkidle0 的表现一致，要研究一下两种的区别</span><br>  timeout: <span class="hljs-number">0</span>, <span class="hljs-comment">// 可以等待页面加载的时间，超出就会报错请求超时 填 0 无限等待</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="需要再去研究的"><a href="#需要再去研究的" class="headerlink" title="需要再去研究的"></a>需要再去研究的</h3><ul><li>load networkidle0 domcontentloaded 三者的区别？</li><li>在 puppeteer 中使用 cheerio 解析 html 文档 和 在浏览器使用 jquery 的表现不同</li><li>node 中异步流程控制与错误处理</li></ul><h2 id="开始爬取需要的数据"><a href="#开始爬取需要的数据" class="headerlink" title="开始爬取需要的数据"></a>开始爬取需要的数据</h2><p>爬取中<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/iRuOZ9.jpg" alt="iRuOZ9"><br>导出为 excel<br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/p0wkT2.jpg" alt="p0wkT2"></p><p>其实就是一个功能及其简单的玩具爬虫</p><h2 id="完整的代码-去掉注释不到-100-行"><a href="#完整的代码-去掉注释不到-100-行" class="headerlink" title="完整的代码 去掉注释不到 100 行"></a>完整的代码 去掉注释不到 100 行</h2><ol><li>循环列表页面得到跳转到详情页的地址 整理成一个数组</li><li>循环得到的数组，依次访问对应的页面，将需要的详情页上的数据整理成数组</li><li>导出数组为 excel</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 请求模块（1.访问网站）</span><br><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;request&quot;</span>);<br><span class="hljs-comment">// 可以看做成node版的jQuery（2.获取页面指定数据源）</span><br><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cheerio&quot;</span>);<br><span class="hljs-comment">// node异步流程控制 异步循环（3.根据页面数据源再访问详情数据）</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">async</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;async&quot;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-comment">// 无头浏览器</span><br><span class="hljs-keyword">const</span> puppeteer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;puppeteer-core&quot;</span>);<br><span class="hljs-comment">// json 导出 excel</span><br><span class="hljs-keyword">const</span> json2xls = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;json2xls&quot;</span>);<br><span class="hljs-keyword">const</span> sleep = <span class="hljs-function">(<span class="hljs-params">time</span>) =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      resolve(<span class="hljs-literal">true</span>);<br>    &#125;, time);<br>  &#125;);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandom</span>(<span class="hljs-params">n, m</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (m - n + <span class="hljs-number">1</span>) + n);<br>  <span class="hljs-keyword">return</span> num;<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestInfo</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;开始请求详情页&quot;</span>, url);<br>  <span class="hljs-comment">//模拟人为操作 打开页面后等待3-10秒</span><br>  <span class="hljs-keyword">await</span> sleep(getRandom(<span class="hljs-number">3000</span>, <span class="hljs-number">10000</span>));<br>  <span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.launch(&#123;<br>    executablePath:<br>      <span class="hljs-string">&quot;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&quot;</span>,<br>    headless: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// args: [ &#x27;--proxy-server=http://188.166.215.141:3128&#x27; ] // 用你的有效代理服务器替换</span><br>  &#125;);<br>  <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> browser.newPage();<br>  <span class="hljs-keyword">await</span> page.goto(url, &#123;<br>    waitUntil: <span class="hljs-string">&quot;load&quot;</span>,<br>    timeout: <span class="hljs-number">0</span>, <span class="hljs-comment">// 可以等待页面加载的时间，超出就会报错请求超时 填 0 无限等待</span><br>  &#125;);<br>  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> page.content();<br>  <span class="hljs-comment">// fs.writeFileSync(&#x27;./test.html&#x27;, html)</span><br>  <span class="hljs-keyword">const</span> $ = cheerio.load(html);<br>  <span class="hljs-keyword">let</span> info = &#123;&#125;;<br>  info.机构名称 = $(<br>    <span class="hljs-string">&quot;#BasicInformation &gt; .leftcontext_left &gt; .leftcontexttitle &gt; label&quot;</span><br>  )<br>    .text()<br>    .trim();<br>  <span class="hljs-comment">// .... 这里处理需要的数据</span><br>  info.数据来源 = url;<br>  browser.close();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;info==&quot;</span>, info);<br>  <span class="hljs-keyword">return</span> info;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestPage</span>(<span class="hljs-params">page = <span class="hljs-number">1</span>, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;开始请求列表页面&quot;</span>, page);<br>  request(<br>    &#123;<br>      url: <span class="hljs-string">&quot;你的目标页面&quot;</span> + page,<br>      method: <span class="hljs-string">&quot;get&quot;</span>,<br>      headers: &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>:<br>          <span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;</span>,<br>        Accept:<br>          <span class="hljs-string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;</span>,<br>        <span class="hljs-comment">// &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;,</span><br>        <span class="hljs-string">&quot;Accept-Language&quot;</span>: <span class="hljs-string">&quot;zh-CN,zh;q=0.9&quot;</span>,<br>        <span class="hljs-string">&quot;Cache-Control&quot;</span>: <span class="hljs-string">&quot;no-cache&quot;</span>,<br>      &#125;,<br>      encoding: <span class="hljs-literal">null</span>,<br>    &#125;,<br>    <span class="hljs-keyword">async</span> (err, res, body) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> list = [];<br>      <span class="hljs-keyword">const</span> $ = cheerio.load(body.toString());<br>      <span class="hljs-comment">// 获取指定元素</span><br>      <span class="hljs-keyword">let</span> item = $(<span class="hljs-string">&quot;#yly_list_div  div[class=&#x27;jiadiantujianjie_but&#x27;]&quot;</span>);<br>      <span class="hljs-comment">// 循环得到元素的跳转地址和名称</span><br>      item.map(<span class="hljs-function">(<span class="hljs-params">i, index</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>        obj.link = $(index).children(<span class="hljs-string">&quot;a&quot;</span>).attr(<span class="hljs-string">&quot;href&quot;</span>);<br>        list.push(obj);<br>      &#125;);<br>      callback(<span class="hljs-literal">null</span>, list);<br>    &#125;<br>  );<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> requestList = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) &#123;<br>    requestList.push(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> &#123;<br>      requestPage(i, callback);<br>    &#125;);<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;requestList&quot;</span>, requestList); <span class="hljs-comment">// [Function, Function] 全是function的数组</span><br>  <span class="hljs-keyword">async</span>.series(requestList, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// async.series 我不会用</span><br>    <span class="hljs-keyword">const</span> arry = [].concat.apply([], result);<br>    <span class="hljs-keyword">const</span> infoList = [];<br>    (<span class="hljs-keyword">async</span> () =&gt; &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; arry.length; index++) &#123;<br>        <span class="hljs-keyword">const</span> reust = <span class="hljs-keyword">await</span> requestInfo(arry[index].link);<br>        infoList.push(reust);<br>      &#125;<br>      <span class="hljs-keyword">const</span> xls = json2xls(infoList);<br>      <span class="hljs-comment">// 将返回结果转成excel</span><br>      fs.writeFileSync(<span class="hljs-string">&quot;成都.xlsx&quot;</span>, xls, <span class="hljs-string">&quot;binary&quot;</span>);<br>      process.exit();<br>    &#125;)();<br>  &#125;);<br>&#125;<br><br>main();<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/94451941">记一次 node 爬虫经历，手把手教你爬虫</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.itfanr.cc/2019/04/10/configuration-development-of-puppeteer/">Puppeteer 配置小记</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>代码人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我重新写博客了</title>
    <link href="/posts/9573d8fb/"/>
    <url>/posts/9573d8fb/</url>
    
    <content type="html"><![CDATA[<h2 id="重新开始搞博客"><a href="#重新开始搞博客" class="headerlink" title="重新开始搞博客"></a>重新开始搞博客</h2><blockquote><p>为什么选 <code>hexo</code> ?</p></blockquote><p>一开始只想有个属于自己的地方写文字记录,静态博客、使用<code>markdown</code>编写就是我的首选了，尤其是 <code>markdown</code> 自由的插入图片、视频，结合免费的图床和云存储服务，就可以把这些媒体文件从文字中分离出来，以后有了自己的动态网站迁移文章也方便。其次是自己以前搭建过 hexo + github pages 的博客, 还有一点很重要：<code>这些东西完全免费</code>，如果你不使用自定义域名的话，连域名的钱的省了。</p><p>所以，这个基于 hexo 的静态博客托管在 <code>Github Pages</code>服务上 <a href="https://github.com/frmachao/frmachao.github.io">仓库地址</a> </p><p>当然免费也是有代价的:</p><ul><li>github 在国内没有服务器,访问速度较慢</li><li>在敏感时间比如<code>两会</code>期间，GitHub 在国内会完全无法访问</li></ul><p>本站点唯一的开销就是 <a href="http://frmachao.top/">frmachao.top</a> 这个域名了，一口气买了 10 年。</p><blockquote><p>评论怎么迁移呢?</p></blockquote><p>这个还没想好，因为现在的评论功能是使用 <code>Gitalk</code> 实现的，后面导出评论数据可能需要自己写个脚本才能批量导出。</p><p>其实不止评论，因为静态博客的原因，很多东西都要借助第三方的插件来实现,比如</p><ul><li>文章阅读量</li><li>网页访问量</li><li>邮件订阅</li><li>在线聊天</li></ul><h2 id="自定义域名与-SSL-证书"><a href="#自定义域名与-SSL-证书" class="headerlink" title="自定义域名与 SSL 证书"></a>自定义域名与 SSL 证书</h2><p>当前基于 hexo 的静态博客 <a href="http://blog.frmachao.top/">frmachao’blog</a> 托管在 <code>Github Pages</code> 服务上。</p><p>域名在购买于阿里云并备案，主要为了使用阿里云免费的<code>SSL</code>证书才备案的域名，结果晚上看了一篇博客 才知道： Github Pages 支持绑定自定义的域名，启用域名绑定后无需用户自行配置。（博客链接忘记了，后面找到后补上）</p><h2 id="评论插件"><a href="#评论插件" class="headerlink" title="评论插件"></a>评论插件</h2><h3 id="使用gitalk评论插件"><a href="#使用gitalk评论插件" class="headerlink" title="使用gitalk评论插件"></a>使用<code>gitalk</code>评论插件</h3><p>遇到问题：gitalk 官方代码采用了第三方提供的 cors proxy 服务，此服务已于 2021 年 1 月 31 日终止</p><p>解决：gitalking 切换到自建的 CORS proxy 参考：</p><ol><li><a href="https://github.com/Zibri/cloudflare-cors-anywhere">https://github.com/Zibri/cloudflare-cors-anywhere</a> 一个代理库</li><li><a href="https://github.com/gitalk/gitalk/issues/429">https://github.com/gitalk/gitalk/issues/429</a> 大家对这个问题的讨论</li></ol><blockquote><p>2021.03.03 Gitalk 作者发布了更新</p></blockquote><p><code>Gitalk</code> 更新版本到 1.7.2 或者修改配置增加 proxy: ‘<a href="https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token&#39;">https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token&#39;</a></p><p>后面自己搭建了 cors 服务，参考: <a href="https://lanyundev.com/posts/1f7efefb">https://lanyundev.com/posts/1f7efefb</a></p><h3 id="Gitalk-原理"><a href="#Gitalk-原理" class="headerlink" title="Gitalk 原理"></a>Gitalk 原理</h3><p>在静态博客中使用评论功能，文章的唯一标示就是页面的<code>location.href</code> 即 url ,gitalk 将 这个唯一标识 作为 issue 的 label 与文章关联，每篇文章对应一个 Issue</p><p><code>fluid主题</code> 里集成 Gitalk 插件时多处理了一步 在 <code>gitalk.ejs</code> 里做了 md5 加密，加密后的值就是 issue 的 label</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> gitalk = <span class="hljs-keyword">new</span> Gitalk(&#123;<br>  clientID: <span class="hljs-string">&#x27;&lt;%= theme.gitalk.clientID %&gt;&#x27;</span>,<br>  clientSecret: <span class="hljs-string">&#x27;&lt;%= theme.gitalk.clientSecret %&gt;&#x27;</span>,<br>  repo: <span class="hljs-string">&#x27;&lt;%= theme.gitalk.repo %&gt;&#x27;</span>,<br>  owner: <span class="hljs-string">&#x27;&lt;%= theme.gitalk.owner %&gt;&#x27;</span>,<br>  admin: &lt;%- <span class="hljs-built_in">JSON</span>.stringify(theme.gitalk.admin || []) %&gt;,<br>  id: <span class="hljs-string">&#x27;&lt;%= md5(page.path) %&gt;&#x27;</span>, <span class="hljs-comment">// 这里做了md5 加密</span><br>  language: <span class="hljs-string">&#x27;&lt;%= theme.gitalk.language %&gt;&#x27;</span>,<br>  labels: &lt;%- <span class="hljs-built_in">JSON</span>.stringify(theme.gitalk.labels || []) %&gt;,<br>  perPage: &lt;%= theme.gitalk.perPage %&gt;,<br>  pagerDirection: <span class="hljs-string">&#x27;&lt;%= theme.gitalk.pagerDirection %&gt;&#x27;</span>,<br>  createIssueManually: &lt;%= theme.gitalk.createIssueManually %&gt;,<br>  distractionFreeMode: &lt;%= theme.gitalk.distractionFreeMode %&gt;,<br>  proxy: <span class="hljs-string">&#x27;&lt;%= theme.gitalk.proxy %&gt;&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><code>page.path</code> :page 是 hexo 中提供的变量，page.path 是页面网址（不含根路径）<br>比如 <code>https://blog.frmachao.top/posts/9573d8fb/</code>这个页面取 page.path 的值就是 <code>posts/9573d8fb/</code></p><p>加密后的 32 位 MD5：<code>f43773bc09059051be6825b5c9006f58</code><br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2023-04-09-FPGr4k.png" alt="2023-04-09-FPGr4k"></p><p><code>https://blog.frmachao.top/links/</code><br>非文章页面取 page.path 的值就是 —&gt; <code>links/index.html </code></p><p>加密后的 32 位 MD5：<code>38687fdbcd50268b872dd8c493f739e6</code><br><img src="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/wYtVZti7RfqJ.png" alt="wYtVZti7RfqJ"></p><p><code>注意⚠️</code>: page.path 取到的 url 路径是 url 解码过的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">2021/03/%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/ <span class="hljs-comment"># url编码</span><br>2021/03/一个博客/  <span class="hljs-comment"># url解码</span><br></code></pre></td></tr></table></figure><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><blockquote><p>目前使用 github 仓库 作为图床</p></blockquote><p>使用 <code>github</code>仓库做图床，利用 public repo 提供的免费 jsdelivr CDN </p><ul><li>仓库地址： <a href="https://github.com/frmachao/images">https://github.com/frmachao/images</a></li><li>图片链接： <a href="https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2023-04-05-5xznzZ.png">https://cdn.jsdelivr.net/gh/frmachao/images@blog/uPic/2023-04-05-5xznzZ.png</a></li><li><a href="http://ping.chinaz.com/raw.githubusercontent.com">ping 检测 raw.githubusercontent.com 在国内的状态</a></li></ul><h2 id="网站统计插件"><a href="#网站统计插件" class="headerlink" title="网站统计插件"></a>网站统计插件</h2><ul><li>使用 <code>leancloud</code> 的服务 统计网页访问数 与 文章阅读数</li><li>百度统计</li></ul><h2 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h2><p>主题使用了 <a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a></p><p>自己做的修改：</p><ul><li>Post.ejs 中添加 AddToAny 插件来支持文章分享</li><li>Post.ejs 中修改 Custom 的位置到文章底部</li></ul><h2 id="测试插入视频"><a href="#测试插入视频" class="headerlink" title="测试插入视频"></a>测试插入视频</h2><blockquote><p><code>javascript</code> 的诞生与死亡</p></blockquote><iframewidth="100%"height="480px"src="//player.bilibili.com/player.html?aid=1623152&bvid=BV1Gx411P7GJ&cid=2467718&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h2 id="hexo-插件"><a href="#hexo-插件" class="headerlink" title="hexo 插件"></a>hexo 插件</h2><ul><li>hexo-abbrlink 生成唯一永久的文章链接<ul><li>hexo 文章链接默认的生成规则是：:year/:month/:day/:title，是按照年、月、日、标题来生成的。</li><li>这个插件可以生成不变的文章链接，不会随着文章标题变动，原理是在文章的 md 文件中新增一个 abbrlink 字段<h2 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h2></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n <span class="hljs-string">&quot;我的博客&quot;</span> == hexo new <span class="hljs-string">&quot;我的博客&quot;</span> <span class="hljs-comment">#新建文章</span><br>hexo new draft &lt;title&gt; <span class="hljs-comment"># 新建草稿</span><br>hexo p == hexo publish<br>hexo g == hexo generate<span class="hljs-comment">#生成</span><br>hexo s == hexo server <span class="hljs-comment">#启动服务预览</span><br>hexo d == hexo deploy<span class="hljs-comment">#部署</span><br>hexo server <span class="hljs-comment">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span><br>hexo server -s <span class="hljs-comment">#静态模式</span><br>hexo s --draft <span class="hljs-comment"># 编译草稿</span><br>hexo server -p 5000 <span class="hljs-comment">#更改端口</span><br>hexo server -i 192.168.1.1 <span class="hljs-comment">#自定义 IP</span><br>hexo clean <span class="hljs-comment">#清除缓存 网页正常情况下可以忽略此条命令</span><br>hexo g <span class="hljs-comment">#生成静态网页</span><br>hexo d <span class="hljs-comment">#开始部署</span><br><br></code></pre></td></tr></table></figure><h2 id="博客的托管"><a href="#博客的托管" class="headerlink" title="博客的托管"></a>博客的托管</h2><p>hexo 博客源码本身存储在 github 上的一个私有仓库 <code>https://github.com/frmachao/hexo-blog</code>,原始的markdown 文章与草稿 hexo 博客主题配置等等都在这里</p><p>当编辑完文章后通过 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a> 这个插件 将hexo 编译出来的 HTML 页面推送到开启 <code>Github Pages</code>静态页面服务的公开仓库中 <code>https://github.com/frmachao/frmachao.github.io</code></p><p>后来觉得手动在本地执行编译 + 推送到静态页面服务仓库麻烦，于是利用 GitHub Actions 自动部署 Hexo 博客<br>参考 ： <a href="https://hexo.fluid-dev.com/posts/actions-deploy/">利用 GitHub Actions 自动部署 Hexo 博客</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">- .github<br>  - workflows<br>    - hexo_deploy.yml <br></code></pre></td></tr></table></figure><p>这是我的 hexo 自动部署配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span>                      <span class="hljs-comment"># Actions 显示的名字，随意设置</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span>                     <span class="hljs-comment"># 监听到 push 事件后触发</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span>              <span class="hljs-comment"># 拉取当前执行 Actions 仓库的指定分支</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">ref:</span> <span class="hljs-string">master</span><br>    <span class="hljs-comment">#- name: Update Submodule      # 如果仓库有 submodule，在这里更新，没有则删掉此步骤</span><br>    <span class="hljs-comment">#  run: |</span><br>    <span class="hljs-comment">#    git submodule init</span><br>        <span class="hljs-comment"># git submodule update --remote</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node</span>            <span class="hljs-comment"># 安装 Node 环境</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">node-version:</span> <span class="hljs-string">&quot;10.x&quot;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Generate</span>         <span class="hljs-comment"># 安装 Hexo 依赖并且生成静态文件</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>        <span class="hljs-string">rm</span> <span class="hljs-string">-f</span> <span class="hljs-string">.yarnclean</span><br>        <span class="hljs-string">yarn</span> <span class="hljs-string">--frozen-lockfile</span> <span class="hljs-string">--ignore-engines</span> <span class="hljs-string">--ignore-optional</span> <span class="hljs-string">--non-interactive</span> <span class="hljs-string">--silent</span> <span class="hljs-string">--ignore-scripts</span> <span class="hljs-string">--production=false</span><br>        <span class="hljs-string">rm</span> <span class="hljs-string">-rf</span> <span class="hljs-string">./public</span><br>        <span class="hljs-string">yarn</span> <span class="hljs-string">run</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><br>        <span class="hljs-string">yarn</span> <span class="hljs-string">run</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Deploy</span>           <span class="hljs-comment"># 部署步骤，这里以 hexo deploy 为例</span><br>      <span class="hljs-attr">env:</span><br>        <span class="hljs-attr">SSH_PRIVATE:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SSH_PRIVATE</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">GIT_NAME:</span> <span class="hljs-string">frmachao</span><br>        <span class="hljs-attr">GIT_EMAIL:</span> <span class="hljs-string">frmachao@126.com</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>        <span class="hljs-string">mkdir</span> <span class="hljs-string">-p</span> <span class="hljs-string">~/.ssh/</span><br>        <span class="hljs-string">echo</span> <span class="hljs-string">&quot;$SSH_PRIVATE&quot;</span> <span class="hljs-string">|</span> <span class="hljs-string">tr</span> <span class="hljs-string">-d</span> <span class="hljs-string">&#x27;\r&#x27;</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">~/.ssh/id_rsa</span><br>        <span class="hljs-string">chmod</span> <span class="hljs-number">600</span> <span class="hljs-string">~/.ssh/id_rsa</span><br>        <span class="hljs-string">ssh-keyscan</span> <span class="hljs-string">github.com</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">~/.ssh/known_hosts</span><br>        <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.name</span> <span class="hljs-string">&quot;$GIT_NAME&quot;</span><br>        <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.email</span> <span class="hljs-string">&quot;$GIT_EMAIL&quot;</span><br>        <span class="hljs-string">yarn</span> <span class="hljs-string">run</span> <span class="hljs-string">hexo</span> <span class="hljs-string">deploy</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>教程</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
